<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>22级天梯赛热身心得</title>
      <link href="/2022/12/08/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%83%AD%E8%BA%AB%E5%BF%83%E5%BE%97/"/>
      <url>/2022/12/08/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%83%AD%E8%BA%AB%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>今天在打完热身赛补题时发现一处以前没注意到的地方，白白浪费了两个小时进行debug，这里记录一下：</p><h2 id="2-1-有理数均值"><a href="#2-1-有理数均值" class="headerlink" title="2-1 有理数均值"></a>2-1 有理数均值</h2><blockquote><p>本题要求编写程序，计算N个有理数的平均值。<br>输入格式：输入第一行给出正整数N（≤100）；第二行中按照a1/b1 a2/b2 …的格式给出N个分数形式的有理数，其中分子和分母全是整形范围内的整数；如果是负数，则负号一定出现在最前面。<br>输出格式：在一行中按照a/b的格式输出N个有理数的平均值。注意必须是该有理数的最简分数形式，若分母为1，则只输出分子。</p></blockquote><p><strong>输入样例1：</strong><br>4<br>1/2 1/6 3/6 -5/10<br><strong>输出样例1：</strong><br>1/6<br><strong>输入样例2：</strong><br>2<br>4/3 2/3<br><strong>输出样例2：</strong><br>1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int gcd(int x,int y);</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,fenzi=0,fenmu=1,up,down,i;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d/%d&quot;,&amp;up,&amp;down);</span><br><span class="line">        if(up==0)</span><br><span class="line">            continue;</span><br><span class="line">        fenzi=up*fenmu+fenzi*down;</span><br><span class="line">        fenmu*=down;</span><br><span class="line">        if(i==n-1)</span><br><span class="line">            fenmu*=n;</span><br><span class="line">        int max_gongyue=gcd(fenzi,fenmu);</span><br><span class="line">        fenzi/=max_gongyue;</span><br><span class="line">        fenmu/=max_gongyue;</span><br><span class="line">    &#125;</span><br><span class="line">    if(fenzi==0)</span><br><span class="line">printf(&quot;0&quot;);</span><br><span class="line">else if(fenmu==1)</span><br><span class="line">        printf(&quot;%d&quot;,fenzi);</span><br><span class="line">else</span><br><span class="line">printf(&quot;%d/%d&quot;,fenzi,fenmu);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int gcd(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    if(y==0)</span><br><span class="line">        return x;</span><br><span class="line">    else</span><br><span class="line">        return gcd(y,x%y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-伙伴"><a href="#3-2-伙伴" class="headerlink" title="3-2 伙伴"></a>3-2 伙伴</h2><blockquote><p>近来，程序社团开始“创客”——用程序来开发一种“找伙伴的数字游戏”。这个伙伴游戏将玩家分为A和B二组。每组每个玩家可以得到一个数字号码。<br>游戏规则是这样的：A组里的每个人的数字与B组里每个人的数字进行“数字配对”——即加法运算，若运算的结果恰巧是B组内其他玩家手捏的数字号码，那么游戏就可以累计一个分值，这个分值就是B组内这个“恰巧”的数字号码。当然，在B组内“恰巧”的数字号码可能不止一个，游戏允许再次累计。<br>比如加法运算后的“恰巧”的数字是3，而B组内共有2个玩家捏有此数字，那么本组就可以得到6分。<br>你是游戏的开发者之一，你需要迅速计算出找伙伴游戏的最终得分。<br><em><strong>输入格式:</strong></em><br>第一行有二个数字n和m，分别表示A组和B组的人数。<br>第二行有n个整数ai，每个整数之间有一个空格，表示n个玩家手中的数字号码。<br>第三行有m个整数bi，每个整数之间有一个空格，表示m个玩家手中的数字号码。</p></blockquote><p><em><strong>输出格式:</strong></em><br>只有一行，一个数字s，表示游戏的最终分数。</p><p><strong>输入样例1:</strong><br>3 3<br>3 5 6<br>2 7 4<br><strong>输出样例1:</strong><br>14<br><strong>样例说明：</strong><br>A组内捏有”3”的玩家与B组内三个玩家进行“数字配对”，遇4时相加后, 发现B组内有一个恰巧的数字“7”;<br>A组内捏有“5”的玩家与B组内三个玩家进行“数字配对”，遇2相加后, 发现B组内有一个恰巧的数字“7”;<br>当A组内捏有“6”的玩家与B组内三个玩家进行“数字配对”，无论与谁的数字相加，都没有在B组发现一个恰巧的数字;<br>因此最终结果是：7+7=14。</p><p><strong>输入样例2:</strong><br>3 3<br>2 5 2<br>6 8 8<br><strong>输出样例2:</strong><br>32<br><strong>样例说明：</strong><br>A组第1玩家捏有数字”2”,与B组进行“数字配对”时，得分8+8;<br>A组第2玩家捏有数字”5”，与B组进行“数字配对”时，得分0;<br>A组第3玩家捏有数字”2”，与B组进行“数字配对”时，得分8+8;<br>因此最终得分为：8+8+8+8。</p><p><strong>【数据规模】</strong><br>30%的数据，1&lt;=n,m&lt;=3，1&lt;=ai,bi&lt;=100<br>50%数据，1&lt;=n,m&lt;=100，1&lt;=ai,bi&lt;=100<br>70%数据，1&lt;=n,m&lt;=10000，1&lt;=ai,bi&lt;=100<br>100%数据，1&lt;=n,m&lt;=100000，1&lt;=ai,bi&lt;=100</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n,x,y;</span><br><span class="line">    long long sum=0;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;m,&amp;n);</span><br><span class="line">    int arr[100000]=&#123;0&#125;,brr[100000]=&#123;0&#125;;</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        arr[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;y);</span><br><span class="line">        brr[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;=100;i++)&#123;</span><br><span class="line">        for(int j=1;i+j&lt;=100;j++)&#123;</span><br><span class="line">            if(arr[i]&gt;0&amp;&amp;brr[j]&gt;0&amp;&amp;brr[i+j]&gt;0)&#123;</span><br><span class="line">                sum+=arr[i]*brr[j]*(i+j)*brr[i+j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h2 id="1-1-重要的话说三遍"><a href="#1-1-重要的话说三遍" class="headerlink" title="1-1 重要的话说三遍"></a>1-1 重要的话说三遍</h2><blockquote><p>这道超级简单的题目没有任何输入。你只需要把这句很重要的话 —— “I’m gonna WIN!”——连续输出三遍就可以了。注意每遍占一行，除了每行的回车不能有任何多余字符。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">        printf(&quot;I&#x27;m gonna WIN!&quot;);</span><br><span class="line">        if(i!=2)</span><br><span class="line">            printf(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-整数积"><a href="#1-2-整数积" class="headerlink" title="1-2 整数积"></a>1-2 整数积</h2><blockquote><p>小明没带草稿纸，心算搞不定整数的乘积，只有请你帮忙设计程序来求输入的任意三个整数的乘积。</p></blockquote><p><em><strong>输入格式:</strong></em><br>输入三个由空格隔开的整数a,b,c，(-1000 &lt; a , b , c &lt; 1000 )</p><p><em><strong>输出格式:</strong></em><br>输出三个整数的乘积</p><p><strong>输入样例:</strong><br>1 2 3<br><strong>输出样例:</strong><br>6</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    long long a,b,c,d;</span><br><span class="line">    scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    d=a*b*c;</span><br><span class="line">    printf(&quot;%lld&quot;,d);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-三天打鱼两天晒网"><a href="#1-3-三天打鱼两天晒网" class="headerlink" title="1-3 三天打鱼两天晒网"></a>1-3 三天打鱼两天晒网</h2><blockquote><p>中国有句俗语叫“三天打鱼两天晒网”。假设某人从某天起，开始“三天打鱼两天晒网”，问这个人在以后的第N天中是“打鱼”还是“晒网”？</p></blockquote><p><em><strong>输入格式：</strong></em><br>输入在一行中给出一个不超过1000的正整数N。</p><p><em><strong>输出格式：</strong></em><br>在一行中输出此人在第N天中是“Fishing”（即“打鱼”）还是“Drying”（即“晒网”），并且输出“in day N”。</p><p><strong>输入样例1：</strong><br>103<br><strong>输出样例1：</strong><br>Fishing in day 103<br><strong>输入样例2：</strong><br>34<br><strong>输出样例2：</strong><br>Drying in day 34</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,x;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    x=n%5;</span><br><span class="line">    if(x&gt;0&amp;&amp;x&lt;=3)</span><br><span class="line">        printf(&quot;Fishing in day %d&quot;,n);</span><br><span class="line">    else</span><br><span class="line">        printf(&quot;Drying in day %d&quot;,n);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-用天平找小球"><a href="#1-4-用天平找小球" class="headerlink" title="1-4 用天平找小球"></a>1-4 用天平找小球</h2><blockquote><p>三个球A、B、C，大小形状相同且其中有一个球与其他球重量不同。要求找出这个不一样的球。</p></blockquote><p><em><strong>输入格式：</strong></em><br>输入在一行中给出3个正整数，顺序对应球A、B、C的重量。</p><p><em><strong>输出格式：</strong></em><br>在一行中输出唯一的那个不一样的球。</p><p><strong>输入样例：</strong><br>1 1 2<br><strong>输出样例：</strong><br>C</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b,c;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    if(a==b)</span><br><span class="line">        printf(&quot;C&quot;);</span><br><span class="line">    else if(a==c)</span><br><span class="line">        printf(&quot;B&quot;);</span><br><span class="line">    else if(b==c)</span><br><span class="line">        printf(&quot;A&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-5-100以内的加法"><a href="#1-5-100以内的加法" class="headerlink" title="1-5 100以内的加法"></a>1-5 100以内的加法</h2><blockquote><p>小明刚上小学一年级，数学老师刚刚教会了100以内的整数加法运算，数学老师期中测试出了一道题，题目为求两个整数之间的所有整数之和，包括边界整数值，小明很是为难？现要你编程帮小明解决问题。</p></blockquote><p><em><strong>输入格式:</strong></em><br>在一行中输入两个边界整数值m,n(1&lt;= m &lt;= n &lt;=100)，中间以空格隔开。</p><p><em><strong>输出格式:</strong></em><br>在一行中输出m到n之间的所有整数和。</p><p><strong>输入样例:</strong><br>2 7<br><strong>输出样例:</strong><br>27</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b,sum=0;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    for(int i=a;i&lt;=b;i++)&#123;</span><br><span class="line">        sum+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-6-循环的统计"><a href="#1-6-循环的统计" class="headerlink" title="1-6 循环的统计"></a>1-6 循环的统计</h2><blockquote><p>在墙角堆放着一堆完全相同的正方体小木块，从上往下数起，第一层是1块，第二层是3块，第三层是6块…… 因为木块堆得实在是太有规律了，你只要知道它的层数就可以计算所有木块的数量了。<br><img src="/2022/12/08/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%83%AD%E8%BA%AB%E5%BF%83%E5%BE%97/0001.png" alt="题目图片"></p></blockquote><p><em><strong>输入格式:</strong></em><br>只有一个整数 n ，表示这堆小木块的层数，已知1 &lt;= n &lt;= 100 。</p><p><em><strong>输出格式:</strong></em><br>只有一个整数，表示这堆小木块的总数量。</p><p><strong>输入样例:</strong><br>5<br><strong>输出样例:</strong><br>35</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,sum1=0,sum=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        sum1+=i;</span><br><span class="line">        sum+=sum1;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,sum);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-7-求特殊方程的正整数解"><a href="#1-7-求特殊方程的正整数解" class="headerlink" title="1-7 求特殊方程的正整数解"></a>1-7 求特殊方程的正整数解</h2><blockquote><p>本题要求对任意给定的正整数N，求方程X^2+Y^2=N的全部正整数解。</p></blockquote><p><em><strong>输入格式：</strong></em><br>输入在一行中给出正整数N（≤10000）。</p><p><em><strong>输出格式：</strong></em><br>输出方程X^2+Y^2=N的全部正整数解，其中X≤Y。每组解占1行，两数字间以1空格分隔，按X的递增顺序输出。如果没有解，则输出No Solution。</p><p><strong>输入样例1：</strong><br>884<br><strong>输出样例1：</strong><br>10 28<br>20 22<br><strong>输入样例2：</strong><br>11<br><strong>输出样例2：</strong><br>No Solution</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,flag=0;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i=0;i&lt;=sqrt(n);i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;sqrt(n);j++)&#123;</span><br><span class="line">            if(i*i+j*j==n&amp;&amp;i&lt;=j)&#123;</span><br><span class="line">                printf(&quot;%d %d\n&quot;,i,j);</span><br><span class="line">                flag=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(!flag)&#123;</span><br><span class="line">        printf(&quot;No Solution&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-8-猜数字游戏"><a href="#1-8-猜数字游戏" class="headerlink" title="1-8 猜数字游戏"></a>1-8 猜数字游戏</h2><blockquote><p>猜数字游戏是令游戏机随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Too big”），还是小了（“Too small”），相等表示猜到了。如果猜到，则结束程序。程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo!”；如果3次以内猜到该数，则提示“Lucky You!”；如果超过3次但是在N（&gt;3）次以内（包括第N次）猜到该数，则提示“Good Guess!”；如果超过N次都没有猜到，则提示“Game Over”，并结束程序。如果在到达N次之前，用户输入了一个负数，也输出“Game Over”，并结束程序。</p></blockquote><p><em><strong>输入格式:</strong></em><br>输入第一行中给出两个不超过100的正整数，分别是游戏机产生的随机数、以及猜测的最大次数N。最后每行给出一个用户的输入，直到出现负数为止。</p><p><em><strong>输出格式:</strong></em><br>在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。</p><p><strong>输入样例:</strong><br>58 4<br>70<br>50<br>56<br>58<br>60<br>-2</p><p><strong>输出样例:</strong><br>Too big<br>Too small<br>Too small<br>Good Guess!</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,t,x,flag=0,num=0;</span><br><span class="line">    scanf(&quot;%d %d&quot;,&amp;n,&amp;t);</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;x)!=EOF)&#123;</span><br><span class="line">        num++;</span><br><span class="line">        if((num&lt;=t&amp;&amp;x&lt;0)||(num&gt;t))&#123;</span><br><span class="line">            printf(&quot;Game Over\n&quot;);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(x&gt;n)&#123;</span><br><span class="line">            printf(&quot;Too big\n&quot;);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(x&lt;n)&#123;</span><br><span class="line">            printf(&quot;Too small\n&quot;);</span><br><span class="line">            flag++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            if(flag==0)&#123;</span><br><span class="line">                printf(&quot;Bingo!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(flag&lt;=2&amp;&amp;flag&gt;=1)&#123;</span><br><span class="line">                printf(&quot;Lucky You!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(flag&gt;2&amp;&amp;flag&lt;t)&#123;</span><br><span class="line">                printf(&quot;Good Guess!\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                printf(&quot;Game Over\n&quot;);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="进阶题"><a href="#进阶题" class="headerlink" title="进阶题"></a>进阶题</h1><h2 id="2-1-有理数均值-1"><a href="#2-1-有理数均值-1" class="headerlink" title="2-1 有理数均值"></a>2-1 有理数均值</h2><ul><li>见文章开头</li></ul><h2 id="2-2-求矩阵的局部极大值"><a href="#2-2-求矩阵的局部极大值" class="headerlink" title="2-2 求矩阵的局部极大值"></a>2-2 求矩阵的局部极大值</h2><blockquote><p>给定M行N列的整数矩阵A，如果A的非边界元素A[i][j]大于相邻的上下左右4个元素，那么就称元素A[i][j]是矩阵的局部极大值。本题要求给定矩阵的全部局部极大值及其所在的位置。</p></blockquote><p><em><strong>输入格式：</strong></em><br>输入在第一行中给出矩阵A的行数M和列数N（3≤M,N≤20）；最后M行，每行给出A在该行的N个元素的值。数字间以空格分隔。</p><p><em><strong>输出格式：</strong></em><br>每行按照“元素值 行号 列号”的格式输出一个局部极大值，其中行、列编号从1开始。要求按照行号递增输出；若同行有超过1个局部极大值，则该行按列号递增输出。若没有局部极大值，则输出“None 总行数 总列数”。</p><p><strong>输入样例1：</strong><br>4 5<br>1 1 1 1 1<br>1 3 9 3 1<br>1 5 3 5 1<br>1 1 1 1 1<br><strong>输出样例1：</strong><br>9 2 3<br>5 3 2<br>5 3 4<br><strong>输入样例2：</strong><br>3 5<br>1 1 1 1 1<br>9 3 9 9 1<br>1 5 3 5 1<br><strong>输出样例2：</strong><br>None 3 5</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n,flag=1;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">    int arr[m+1][n+1];</span><br><span class="line">    for(int i=0;i&lt;m;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int i=1;i&lt;m-1;i++)&#123;</span><br><span class="line">        for(int j=1;j&lt;n-1;j++)&#123;</span><br><span class="line">            if((arr[i][j]&gt;arr[i-1][j])&amp;&amp;(arr[i][j]&gt;arr[i][j-1])&amp;&amp;(arr[i][j]&gt;arr[i+1][j])&amp;&amp;(arr[i][j]&gt;arr[i][j+1]))&#123;</span><br><span class="line">                printf(&quot;%d %d %d\n&quot;,arr[i][j],i+1,j+1);</span><br><span class="line">                flag=0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)&#123;</span><br><span class="line">        printf(&quot;None %d %d&quot;,m,n);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-3-傻傻分不清楚"><a href="#2-3-傻傻分不清楚" class="headerlink" title="2-3 傻傻分不清楚"></a>2-3 傻傻分不清楚</h2><blockquote><p>有一次小Y的键盘的大写键坏了（打字母随机大小写），但他现在需要照着打几段字符串（只有英文字母），不过他有时候会有点粗心会打错字母。然后现在我需要眼尖的你来帮帮我帮我找出他有没有粗心（只是大小写不同不算粗心），如果没有请你告诉我键盘一共坏了几次。</p></blockquote><p><em><strong>输入格式:</strong></em><br>输入第一行给出正整数N，代表他接下来要打的字符串数量。<br>随后给出2N行字符串，两两对应。<br>每段字符串长度小于100。本题多组数据。</p><p><em><strong>输出格式:</strong></em><br>每两个字符串输出一行，如果他粗心了输出“NO!”，没有粗心输出“YES!”并在后面空一格输出键盘坏的次数</p><p><strong>输入样例:</strong><br>在这里给出一组输入。例如：<br>2<br>abcdfef<br>aBCdfef<br>c<br>c<br>1<br>qwer<br>QEWr<br><strong>输出样例:</strong><br>在这里给出相应的输出。例如：<br>YES! 2<br>YES! 0<br>NO!</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,flag=0,i;</span><br><span class="line">    char arr[105],brr[105];</span><br><span class="line">    while(scanf(&quot;%d&quot;,&amp;n)!=EOF)&#123;</span><br><span class="line">        scanf(&quot;%s%s&quot;,arr,brr);</span><br><span class="line">        for(i=0;i&lt;strlen(arr);i++)&#123;</span><br><span class="line">                if((arr[i]==brr[i]))</span><br><span class="line">                    continue;</span><br><span class="line">                else if((arr[i]-32==brr[i])||(arr[i]+32==brr[i]))&#123;</span><br><span class="line">                    flag++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                else&#123;</span><br><span class="line">                    printf(&quot;NO!\n&quot;);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(i==strlen(arr))&#123;</span><br><span class="line">            printf(&quot;YES! %d\n&quot;,flag);</span><br><span class="line">        &#125;</span><br><span class="line">        for(i=0;i&lt;strlen(arr);i++)&#123;</span><br><span class="line">            arr[i]=0;</span><br><span class="line">            brr[i]=0;</span><br><span class="line">        &#125;</span><br><span class="line">        flag=0;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-谁先倒"><a href="#2-4-谁先倒" class="headerlink" title="2-4 谁先倒"></a>2-4 谁先倒</h2><blockquote><p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。下面给出甲、乙两人的酒量（最多能喝多少杯不倒）和划拳记录，请你判断两个人谁先倒。</p></blockquote><p><em><strong>输入格式：</strong></em><br>输入第一行先后给出甲、乙两人的酒量（不超过100的非负整数），以空格分隔。下一行给出一个正整数N（≤100），随后N行，每行给出一轮划拳的记录，格式为：<br><strong>甲喊 甲划 乙喊 乙划</strong><br>其中喊是喊出的数字，划是划出的数字，均为不超过100的正整数（两只手一起划）。</p><p><em><strong>输出格式：</strong></em><br>在第一行中输出先倒下的那个人：A代表甲，B代表乙。第二行中输出没倒的那个人喝了多少杯。题目保证有一个人倒下。注意程序处理到有人倒下就终止，后面的数据不必处理。</p><p><strong>输入样例：</strong><br>1 1<br>6<br>8 10 9 12<br>5 10 5 10<br>3 8 5 12<br>12 18 1 13<br>4 16 12 15<br>15 1 1 16<br><strong>输出样例：</strong><br>A<br>1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m,n,t,jh,jhw,yh,yhw,flag1=0,flag2=0;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d%d%d%d&quot;,&amp;jh,&amp;jhw,&amp;yh,&amp;yhw);</span><br><span class="line">        if(jhw==jh+yh&amp;&amp;yhw!=jh+yh)&#123;</span><br><span class="line">            flag1++;</span><br><span class="line">            &#125;</span><br><span class="line">        if(yhw==jh+yh&amp;&amp;jhw!=jh+yh)&#123;</span><br><span class="line">            flag2++;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag1&gt;m)&#123;</span><br><span class="line">            printf(&quot;A\n%d&quot;,flag2);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        if(flag2&gt;n)&#123;</span><br><span class="line">            printf(&quot;B\n%d&quot;,flag1);</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="登顶题"><a href="#登顶题" class="headerlink" title="登顶题"></a>登顶题</h1><h2 id="3-1-帅到没朋友"><a href="#3-1-帅到没朋友" class="headerlink" title="3-1 帅到没朋友"></a>3-1 帅到没朋友</h2><blockquote><p>当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。</p></blockquote><p><em><strong>输入格式：</strong></em><br>输入第一行给出一个正整数N（≤100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（≤10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。</p><p>注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。</p><p><strong>输出格式：</strong><br>按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出No one is handsome。</p><p><strong>注意：同一个人可以被查询多次，但只输出一次。</strong></p><p><strong>输入样例1：</strong><br>3<br>3 11111 22222 55555<br>2 33333 44444<br>4 55555 66666 99999 77777<br>8<br>55555 44444 10000 88888 22222 11111 23333 88888<br><strong>输出样例1：</strong><br>10000 88888 23333<br><strong>输入样例2：</strong><br>3<br>3 11111 22222 55555<br>2 33333 44444<br>4 55555 66666 99999 77777<br>4<br>55555 44444 22222 11111<br><strong>输出样例2：</strong><br>No one is handsome</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n,x,y,t,num,flag=1;</span><br><span class="line">    int arr[100000]=&#123;0&#125;;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int j=0;j&lt;n;j++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;x);</span><br><span class="line">        for(int i=0;i&lt;x;i++)&#123;</span><br><span class="line">            scanf(&quot;%d&quot;,&amp;y);</span><br><span class="line">            if(x!=1)</span><br><span class="line">            arr[y]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;t);</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;num);</span><br><span class="line">        if(arr[num]==0)&#123;</span><br><span class="line">            flag=0;</span><br><span class="line">            printf(&quot;%05d&quot;,num);</span><br><span class="line">            if(t&gt;1)</span><br><span class="line">                printf(&quot; &quot;);</span><br><span class="line">            arr[num]=1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(flag)</span><br><span class="line">            printf(&quot;No one is handsome&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-2-伙伴-1"><a href="#3-2-伙伴-1" class="headerlink" title="3-2 伙伴"></a>3-2 伙伴</h2><ul><li>见文章开头</li></ul><h2 id="3-3-密文游戏"><a href="#3-3-密文游戏" class="headerlink" title="3-3 密文游戏"></a>3-3 密文游戏</h2><blockquote><p>JLU最近流行密文游戏。发送者把信息（原文）按约定的规则变成密文发给接收者,接收者拿到密文按解密规则得到原文。其它人不知道加密解密规则，即使拿到信息的密文，也无法得知原文。<br>小明是你的好朋友，想和你一起玩密文游戏。你俩约定了一个简单的加密解密方案：字符 0 映射字母 A，字符 1 映射字母 B，依次类推，字符 9 映射字母 J。例如：原文1314的密文为BDBE。<br>昨天，你给小明发了一条信息。由于未知原因，密文到小明那里发生了缺失。今天上课，你俩见面对照了原文和密文，发现密文丢失了若干字符。设原文S的长度为n，密文T的长度为m，小明突发奇想：对照原文，有多少种方案能把密文补全，字母数量和位置不同，都视为不同的方案。作为好友的你,帮他计算一下吧。</p></blockquote><p><em><strong>输入格式:</strong></em><br>第一行，原文S，长度为n(2≤n≤2000)。<br>第二行，密文T，长度为m(1≤m ≤ n-1 )。</p><p><em><strong>输出格式:</strong></em><br>一行，所求的方案数</p><p><strong>输入样例:</strong><br>在这里给出一组输入。例如：<br>1414<br>BE<br><strong>输出样例:</strong><br>在这里给出相应的输出。例如：<br>3<br><strong>样例说明</strong><br>样例中3种补全方案如下。（）中代表所补的密文。<br>BE(BE)<br>B(EB)E<br>(BE)BE</p><p><em><strong>解析还未出炉，先看看别的吧~</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制转换</title>
      <link href="/2022/12/04/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2022/12/04/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="十进制转d进制-d-lt-10"><a href="#十进制转d进制-d-lt-10" class="headerlink" title="十进制转d进制(d&lt;10)"></a>十进制转d进制(d&lt;10)</h2><p>原理很简单，按照计算方法算出每一位后存入数组，倒序输出即可~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,i=0,x,j,d;</span><br><span class="line">  int arr[1000];</span><br><span class="line">  scanf(&quot;%d%d&quot;,&amp;n,&amp;d);</span><br><span class="line">  if(n==0)</span><br><span class="line">    printf(&quot;0&quot;);</span><br><span class="line">  else&#123;</span><br><span class="line">  while(n&gt;0)&#123;        //想不起来的话把d设成2自己代入一遍</span><br><span class="line">    x=n%d;</span><br><span class="line">    n/=d;</span><br><span class="line">    arr[i]=x;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  for(j=i-1;j&gt;=0;j--)&#123;    //逆序输出</span><br><span class="line">    printf(&quot;%d&quot;,arr[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d进制转十进制（d-lt-10"><a href="#d进制转十进制（d-lt-10" class="headerlink" title="d进制转十进制（d&lt;10)"></a>d进制转十进制（d&lt;10)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,x=1,num=0,d;</span><br><span class="line">  scanf(&quot;%d%d&quot;,&amp;n,&amp;d);</span><br><span class="line">  while(n&gt;0)&#123;</span><br><span class="line">    num+=(n%10)*x;    //拨出最后一位乘以位权</span><br><span class="line">    n/=10;    //舍弃最后一位</span><br><span class="line">    x*=d;    //位权增加</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%d&quot;,num);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="十进制转十六进制"><a href="#十进制转十六进制" class="headerlink" title="十进制转十六进制"></a>十进制转十六进制</h2><p>与前面的“十进制转d进制”差不多，只是用<em>字符数组</em>代替了<em>整型数组</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,i=0,j;</span><br><span class="line">  char arr[1000],brr[20]=&#123;&quot;0123456789ABCDEF&quot;&#125;;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">  if(n==0)</span><br><span class="line">    printf(&quot;0&quot;);</span><br><span class="line">  else&#123;</span><br><span class="line">  while(n&gt;0)&#123;</span><br><span class="line">    arr[i]=brr[n%16];</span><br><span class="line">    n/=16;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  for(j=i-1;j&gt;=0;j--)&#123;</span><br><span class="line">    printf(&quot;%c&quot;,arr[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>在查找资料的时候发现C艹自带进制转换的函数，顺便记录一下~</p><blockquote><p>oct 是八进制形式<br> dec 是十进制形式<br> hex 是十六进制形式（setiosflags(ios::uppercase)可转换为大写输出）<br>C语言没有专门的二进制转换，故只能规定位数输出二进制</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;bitset&lt;8&gt;(n)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;oct&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;dec&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::uppercase)&lt;&lt;hex&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归与递推</title>
      <link href="/2022/12/03/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/"/>
      <url>/2022/12/03/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<p>递归与递推是编程问题中重要的思想，如何更好的理解？看完这篇文章你可能会有收获。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h2><blockquote><p>递归，就是在运行的过程中不断调用自己本身。可以分为“递”和“归”两个过程，“递”得到每一个小步的结果，再通过“归”将每次运算的结果结合起来。最后得到答案。</p></blockquote><h2 id="递归优缺点"><a href="#递归优缺点" class="headerlink" title="递归优缺点"></a>递归优缺点</h2><ul><li>优点：代码简解易懂，思维方式符合我们思考的逻辑。</li><li>缺点：运行效率低，需要调用很多栈来储存返回点和局部量等，容易造成栈溢出。</li></ul><h1 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h1><h2 id="递推定义"><a href="#递推定义" class="headerlink" title="递推定义"></a>递推定义</h2><blockquote><p>递推，就是从问题的初始条件出发，通过观察得出某种关系式，通过这个关系式推出各项结果。</p></blockquote><h2 id="递推优缺点"><a href="#递推优缺点" class="headerlink" title="递推优缺点"></a>递推优缺点</h2><ul><li>优点：很好的发挥了计算机重复计算的优点，不会像递推一样占用过多的内存空间。</li><li>缺点：想象不到递推的关系式，从源头上直接gg（doge 。</li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="裴波那契数列"><a href="#裴波那契数列" class="headerlink" title="裴波那契数列"></a>裴波那契数列</h2><blockquote><p>有一对小兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。按此规律，假设没有兔子死亡，第一个月有一对刚出生的小兔子，问第n个月有多少对兔子？</p></blockquote><p>在草稿纸上进行简单的演算，我们会发现:第一个月1对，第二个月1对，第三个月2对，第四个月3对，第五个月5对，第六个月8对，第七个月13对……<strong>从第三项开始，每个月的数量都是前两个月的和</strong></p><p>不难得出，<strong>当n&gt;=3时，本月兔子数量=上个月数量+上上个月数量</strong>。</p><p>递归、递推代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int digui(int n)    //递归</span><br><span class="line">&#123;</span><br><span class="line">    if(n==1||n==2)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return (digui(n-1)+digui(n-2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ditui(int n)    //递推</span><br><span class="line">&#123;</span><br><span class="line">    int x=1,y=1,z;</span><br><span class="line">    if(n==1||n==2)</span><br><span class="line">        z=1;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i=0;i&lt;n-2;i++)&#123;</span><br><span class="line">        z=x+y;</span><br><span class="line">        x=y;</span><br><span class="line">        y=z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%d\n&quot;,digui(n));</span><br><span class="line">    printf(&quot;%d\n&quot;,ditui(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高中往事回忆</title>
      <link href="/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/"/>
      <url>/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p><strong>后期会持续推出<del>敬请期待</del></strong></p><p><img src="/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/0000.jpg" alt="和本组的帅哥美女"></p>]]></content>
      
      
      <categories>
          
          <category> 回忆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈各种排序</title>
      <link href="/2022/11/30/%E6%B5%85%E8%B0%88%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/11/30/%E6%B5%85%E8%B0%88%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序是我们在学习编程的过程中经常用的问题，这篇博客会总结一些我比较常用的一些算法，以供复习和回忆。</p><p>比较常见的排序大致分为两种，<strong>比较型排序</strong>和<strong>非比较型排序</strong></p><ul><li>比较型排序将元素之间两两进行比较，<em>比较耗时间</em>。</li><li>非比较型排序将元素进行记录，<em>比较耗空间</em>。</li></ul><p><em><strong>我们通常认为时间比空间重要，故经常使用牺牲空间的方式来减少运行时间</strong></em></p><h2 id="比较型排序"><a href="#比较型排序" class="headerlink" title="比较型排序"></a>比较型排序</h2><h3 id="一、插入排序"><a href="#一、插入排序" class="headerlink" title="一、插入排序"></a>一、插入排序</h3><p>一个无序数列，从左到右每次取一个数向左依次比较，直至左边有一个数比它小，则插入。</p><blockquote><p>时间复杂度：O(N)~O(N<sup>2)<br>空间复杂度：O(1)</sup></p></blockquote><p>代码部分：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void InsertSort(int arr[],int n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n-1;++i)&#123;  //第一个已经排好序，没必要再参与计算</span><br><span class="line">        int end=i;    //记录有序序列当前最后元素的下标</span><br><span class="line">        int temp=arr[end+1];    //待插入的元素</span><br><span class="line">        while(end&gt;=0)&#123;</span><br><span class="line">            if(arr[end]&gt;temp)&#123;    </span><br><span class="line">                arr[end+1]=arr[end];    //比插入的数大就向后移</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;    //比插入的数小，跳出循环</span><br><span class="line">        &#125;</span><br><span class="line">        arr[end+1]=temp;    //放入temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[20],i,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    InsertSort(arr,n);</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><p>也是我比较喜欢用的一种排序，每次从左到右相邻的元素两两比较，第一个与第二个比较，让大的那个与第三个比较。这样可以使最大的数排在最右边。</p><blockquote><p>时间复杂度：O(N)~O(N<sup>2)<br>空间复杂度：O(1)</sup></p></blockquote><p>代码部分：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void BubbleSort(int arr[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,temp=0;</span><br><span class="line">    for(i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">        for(j=i+1;j&lt;n;j++)&#123;</span><br><span class="line">            if(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                temp=arr[i];</span><br><span class="line">                arr[i]=arr[j];</span><br><span class="line">                arr[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[20],i,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    BubbleSort(arr,n);</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非比较型排序"><a href="#非比较型排序" class="headerlink" title="非比较型排序"></a>非比较型排序</h2><h3 id="计数排序（Count-sort）"><a href="#计数排序（Count-sort）" class="headerlink" title="计数排序（Count sort）"></a>计数排序（Count sort）</h3><p>计数排序也就是我们刚接触数组时使用的排序方法，快于任何一种比较型排序算法，但条件较为苛刻：<strong>数据范围较小，否则非常浪费空间</strong></p><blockquote><p><strong>k为数组长度</strong><br>时间复杂度就是O(n+k)<br>空间复杂度为O(k)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[1000],brr[1000]=&#123;0&#125;;</span><br><span class="line">    int n,i,j;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;arr[0]);</span><br><span class="line">    brr[arr[0]]++;</span><br><span class="line">    int max=arr[0];</span><br><span class="line">    for(i=1;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">        brr[arr[i]]++;</span><br><span class="line">        if(arr[i]&gt;max)</span><br><span class="line">            max=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;max+1;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;brr[i];j++)&#123;</span><br><span class="line">            printf(&quot;%d &quot;,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈二分查找</title>
      <link href="/2022/11/29/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/11/29/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>相信我们都在编程过程中遇见查找问题，而查找的方式有许多种，我们最常见的、也是使用次数最多的便是<em><strong>二分查找</strong></em>了，原理简单且不容易超时。<br>二分查找的思想很容易理解，但大多数人都是通过记模板来使用，这篇博客将二分法做一个大概的总结，以供记忆和复习。</p><h2 id="一、分享小故事"><a href="#一、分享小故事" class="headerlink" title="一、分享小故事"></a>一、分享小故事</h2><p>这里引用了CSDN中<a href="https://blog.csdn.net/qq_45978890/article/details/116094046?spm=1001.2014.3001.5502">Charon_cc</a>的一个很生动形象的例子：</p><hr><blockquote><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1 本书。</p></blockquote><hr><p>多读两遍我们就会发现<mark>二分查找法的前提<mark>：</mark></mark></p><h2 id="二、二分查找的前提"><a href="#二、二分查找的前提" class="headerlink" title="二、二分查找的前提"></a>二、二分查找的前提</h2><ul><li><strong>查找的目标只能有一个</strong></li><li><strong>查找的范围内元素是有序的</strong>（排序在C++里可以直接使用sort，而在C里可以使用冒泡排序等方法）</li></ul><p>为什么是这样的一个前提呢？我们首先应该知道<mark>二分查找的原理<mark>：</mark></mark></p><h2 id="三、二分查找的原理"><a href="#三、二分查找的原理" class="headerlink" title="三、二分查找的原理"></a>三、二分查找的原理</h2><blockquote><p>在一个已经从小到大排好的数组里，先把目标与数组中间值比较<br>* 若目标&gt;中间值，则接着找后半部分，前半部分舍弃。<br>* 若目标&lt;中间值，则接着找前半部分，后半部分舍弃。</p></blockquote><p>那有初学的朋友会问了：<em>数组元素数是偶数的话怎么取中间值？</em></p><p>其实不必纠结这个问题，因为每次都丢掉数组的一半的话，这个问题是一定会出现的。</p><p>虽说叫二分查找，但并不是说我们必须严格的取一半，只是取一半时舍弃掉的不合要求的元素最多，比较节约时间而已。<br>而由于我们使用<strong>int</strong>类型，每次取的就是最中间两个数中靠左的那个，这样一来无非是在搜索的范围里多加一个数而已，只要我们继续进行二分查找并找好边界值，就永远不会有元素被落下。</p><h2 id="四、二分查找的使用"><a href="#四、二分查找的使用" class="headerlink" title="四、二分查找的使用"></a>四、二分查找的使用</h2><p>这里只写我最常用的一种方式：<mark>[left,right]式<mark><br>使用int函数进行运算：</mark></mark></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int binarysearch(int arr[],int size,int target)</span><br><span class="line">&#123;</span><br><span class="line">    //size 可使用int size=sizeof(arr)/sizeof(arr[0])计算</span><br><span class="line"></span><br><span class="line">    int l=0,r=size-1;   //l=left,r=right,m=middle</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        int m=l+(r-l)/2;    //防止直接相加导致溢出</span><br><span class="line">        if(arr[m]&gt;target)&#123;</span><br><span class="line">            r=m-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(arr[m]&lt;target)&#123;</span><br><span class="line">            l=m+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return m;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、二分查找的性能"><a href="#五、二分查找的性能" class="headerlink" title="五、二分查找的性能"></a>五、二分查找的性能</h2><ul><li>时间复杂度：O(1)~O(log<sub>2</sub>n)</li><li>空间复杂度：O(1)~O(log<sub>2</sub>n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公因数和最小公倍数（欧几里得算法）</title>
      <link href="/2022/11/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
      <url>/2022/11/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>我们在学习时经常性遇见求最大公因数和最小公倍数的问题，而使用枚举的话非常容易超时，那么我们应该怎样更快更好地解决它们呢?</p><span id="more"></span><h2 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>又称<em>辗转相除法</em>，使用int类型的函数实现，两个参数的传入条件要求<em><strong>a大于b</strong></em>。<br><strong>百度百科</strong>：欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。<br>总之就是不断把<em>除数当被除数，余数当除数</em><br>假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：<br>1997 ÷ 615 = 3 (余 152)<br>615 ÷ 152 = 4(余7)<br>152 ÷ 7 = 21(余5)<br>7 ÷ 5 = 1 (余2)<br>5 ÷ 2 = 2 (余1)<br>2 ÷ 1 = 2 (余0)<br>至此，最大公约数为1<br>以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    if(a&lt;b)&#123;  //使大的作被除数</span><br><span class="line">        t=a;a=b;b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b==0)  //判断是否存在0的情况</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;%d&quot;,gcd(a,b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>相信你已经学会求最大公因数，那么最小公倍数呢？<br><strong>当然也是非常简单滴！</strong><br><em><strong>最小公倍数=（ab）/最大公因数</strong></em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    if(a&lt;b)&#123;  //使大的作被除数</span><br><span class="line">        t=a;a=b;b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b==0)  //判断是否存在0的情况</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;%d&quot;,(a*b)/gcd(a,b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 求数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/messageboard/index.html"/>
      <url>/messageboard/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>myself</title>
      <link href="/myself/index.html"/>
      <url>/myself/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
