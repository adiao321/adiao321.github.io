<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>22级天梯赛题解</title>
      <link href="/2022/12/11/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/12/11/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h2 id="1-1-无所谓，我会出手"><a href="#1-1-无所谓，我会出手" class="headerlink" title="1-1 无所谓，我会出手"></a>1-1 无所谓，我会出手</h2><blockquote><p>请直接输出 ：“It doesn’t matter,I’ll do it.”（输出不含引号）。</p></blockquote><ul><li>直接输出即可。<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    printf(&quot;It doesn&#39;t matter,I&#39;ll do it.&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="1-2-数组总和"><a href="#1-2-数组总和" class="headerlink" title="1-2 数组总和"></a>1-2 数组总和</h2><blockquote><p>给出一个正整数 n 和一段长度为n的数组a1,a2…an ，请输出1×a1+2×a2+3×a3+4×a 4​+…+n×an的结果。</p></blockquote><p><em><strong>输入格式</strong></em><br>第一行为 整数 n（1&lt;=n&lt;=1e3)<br>第二行为n 个整数 ai（1&lt;=ai&lt;=1e9）</p><p><em><strong>输出格式</strong></em><br>输出一行一个正整数，代表题目要求的值。</p><p><strong>样例输入</strong><br>4<br>1 2 3 4<br><strong>样例输出</strong><br>30</p><ul><li>使用for循环，初始化i=1，每次相乘后储存到sum里。<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,i;    long long sum&#x3D;0,x;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;x);        sum+&#x3D;x*i;    &#125;    printf(&quot;%lld&quot;,sum);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="1-3-捡到一个矩形"><a href="#1-3-捡到一个矩形" class="headerlink" title="1-3 捡到一个矩形"></a>1-3 捡到一个矩形</h2><blockquote><p>这天，我捡到了一个二维坐标轴，坐标轴上有一个矩形，现在给出一个点的坐标，问这个坐标是否在矩形中。</p></blockquote><p><em><strong>输入格式</strong></em><br>输入第一行一个整数t，代表测试组数 (1&lt;=t&lt;=10)<br>接下来2×t行，每组测试用例第一行为四个整数，分别为正方形的左下角的坐标x1，y1和矩形的右上角 x2，y2<br>第二行为询问的点的坐标 x，y(−1e9&lt;=x,y,x1,x2,y1,y2&lt;=1e9)</p><p><em><strong>输出格式</strong></em><br>如果在矩形中或者在矩形的边界上，输出 YES；否则输出 NO。</p><p><strong>样例输入</strong><br>2<br>0 0 2 2<br>1 1<br>1 1 2 2<br>0 0<br><strong>样例输出</strong><br>YES<br>NO</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,i,x1,x2,y1,y2,x,y;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        if(x&gt;&#x3D;x1&amp;&amp;x&lt;&#x3D;x2&amp;&amp;y&gt;&#x3D;y1&amp;&amp;y&lt;&#x3D;y2)            printf(&quot;YES\n&quot;);        else            printf(&quot;NO\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-字符转换"><a href="#1-4-字符转换" class="headerlink" title="1-4 字符转换"></a>1-4 字符转换</h2><blockquote><p>现给你一种对字符的操作，使其变成该字符在字母表后的第x个位置，x为该字符在字母表中的位置。例如，对字符a进行操作，会将其变成a后的第一个字母，即b；对字符b进行操作，会将其变成b后的第二个字母，即d….以此类推。需要注意的是，该字母表是一个循环字母表，即字符z后的第一个字符是a，a后又是b，循环往复。现在给你一个字符串s，s 均由小写字母组成，1&lt;=∣s∣&lt;=1e5，请输出对字符串s的每一位字符进行操作后的结果。</p></blockquote><p><em><strong>输入格式</strong></em><br>一行输入一个字符串s，含义如题面所示</p><p><em><strong>输出格式</strong></em><br>输出一行一个字符串，代表对s每一位字符进行操作后的结果。</p><p><strong>样例输入</strong><br>upupup<br><strong>样例输出</strong><br>pfpfpf</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    char arr[100005];    scanf(&quot;%s&quot;,arr);    for(int i&#x3D;0;arr[i]!&#x3D;&#39;\0&#39;;i++)&#123;        if(arr[i]-&#39;a&#39;+1&gt;13)            arr[i]-&#x3D;25-arr[i]+&#39;a&#39;;        else        arr[i]+&#x3D;arr[i]-&#39;a&#39;+1;    &#125;    for(int i&#x3D;0;arr[i]!&#x3D;&#39;\0&#39;;i++)&#123;        printf(&quot;%c&quot;,arr[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-捡到了一个成绩"><a href="#1-5-捡到了一个成绩" class="headerlink" title="1-5 捡到了一个成绩"></a>1-5 捡到了一个成绩</h2><blockquote><p>天梯赛过后，所有同学的成绩被打印在一张纸上。现在老师想要统计某班得分的均值，以及得分高于这个均值的同学们的分数之和，请你帮助老师计算出这两个值。</p></blockquote><p><em><strong>输入格式</strong></em><br>第一行输入一个正整数n，代表该班级的人数。(1&lt;=n&lt;=30)<br>第二行输入n个整数，代表第i名同学的得分x。(0&lt;=x&lt;=290)</p><p><em><strong>输出格式</strong></em><br>输出两行，第一行输出一个实数，代表得分的均值。(保留到小数点后三位)<br>第二行输出一个整数，代表得分高于该班级分数均值的同学们的分数之和。</p><p><strong>样例输入</strong><br>6<br>13 105 237 173 273 134<br><strong>样例输出</strong><br>155.833<br>683</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,sum&#x3D;0,sum2&#x3D;0,arr[10000];    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);        sum+&#x3D;arr[i];    &#125;    double aver&#x3D;sum*1.0&#x2F;n;    for(int i&#x3D;0;i&lt;n;i++)&#123;        if(arr[i]*1.0&gt;aver)            sum2+&#x3D;arr[i];    &#125;    printf(&quot;%.3lf\n%d&quot;,aver,sum2);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-6-炎爆"><a href="#1-6-炎爆" class="headerlink" title="1-6 炎爆"></a>1-6 炎爆</h2><blockquote><p>cys学姐非常喜欢Arknights这款游戏，而其中伊芙利特是她最引以为傲的干员之一。给你一个n×n的矩形a，矩形中的每一个位置都有一个敌人，其中a[x][y]代表矩形第x行，第y列上的敌人。假设伊芙利特部署在(x,y)的位置上，并且朝向右，那么伊芙利特会对(x,y),(x,y+1),(x,y+2)….(x,n)的所有敌人造成1点伤害。现在给你q次部署，每次部署都给出一个部署位置(x,y)，代表伊芙利特部署在矩形的第x行，第y列，再给出一个字符op，代表伊芙利特的朝向（U代表向上，R代表向右，D代表向下，L代表向左）。你能精确算出每个敌人受到的伤害吗？</p></blockquote><p><em><strong>输入格式</strong></em><br>第一行一个正整数n，代表矩形的大小(1&lt;=n&lt;=100)，初始情况下所有敌人受到的伤害为0。<br>第二行给出一个正整数q，代表伊芙利特的部署次数(1&lt;=q&lt;=50)。<br>接下来q行，每行给定一个数对(x,y)，1&lt;=x,y&lt;=n，代表伊芙利特的部署位置，和一个字符op，op∈{U,R,D,L}，代表伊芙利特的朝向。</p><p><em><strong>输出格式</strong></em><br>输出n行，每行n个整数，分别对应矩阵a中每个敌人受到的伤害。</p><p><strong>样例输入</strong><br>5<br>3<br>2 2 R<br>4 3 U<br>5 5 L<br><strong>样例输出</strong><br>0 0 1 0 0<br>0 1 2 1 1<br>0 0 1 0 0<br>0 0 1 0 0<br>1 1 1 1 1<br><img src="/2022/12/11/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%A2%98%E8%A7%A3/0002.png" alt="题目图片"></p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,x,numx,numy;    char dire;    scanf(&quot;%d&quot;,&amp;n);    int arr[n+1][n+1];    for(int i&#x3D;0;i&lt;n;i++)&#123;        for(int j&#x3D;0;j&lt;n;j++)&#123;            arr[i][j]&#x3D;0;        &#125;    &#125;    scanf(&quot;%d&quot;,&amp;x);    for(int i&#x3D;0;i&lt;x;i++)&#123;        scanf(&quot;%d%d %c&quot;,&amp;numx,&amp;numy,&amp;dire);        if(dire&#x3D;&#x3D;&#39;U&#39;)&#123;            for(int z&#x3D;0,j&#x3D;0;j&lt;numx;j++,z++)&#123;                arr[numx-1-z][numy-1]++;            &#125;        &#125;        else if(dire&#x3D;&#x3D;&#39;R&#39;)&#123;            for(int z&#x3D;0,j&#x3D;0;j&lt;n-numy+1;j++,z++)&#123;                arr[numx-1][numy-1+z]++;            &#125;        &#125;        else if(dire&#x3D;&#x3D;&#39;D&#39;)&#123;            for(int z&#x3D;0,j&#x3D;0;j&lt;n-numx+1;j++,z++)&#123;                arr[numx-1+z][numy-1]++;            &#125;        &#125;        else if(dire&#x3D;&#x3D;&#39;L&#39;)&#123;            for(int z&#x3D;0,j&#x3D;0;j&lt;numy;j++,z++)&#123;                arr[numx-1][numy-1-z]++;            &#125;        &#125;    &#125;    for(int i&#x3D;0;i&lt;n;i++)&#123;        for(int j&#x3D;0;j&lt;n;j++)&#123;            if(j&#x3D;&#x3D;0)                printf(&quot;%d&quot;,arr[i][j]);            else            printf(&quot; %d&quot;,arr[i][j]);            if(j&#x3D;&#x3D;n-1)                printf(&quot;\n&quot;);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-7-攻略迷宫"><a href="#1-7-攻略迷宫" class="headerlink" title="1-7 攻略迷宫"></a>1-7 攻略迷宫</h2><blockquote><p>小A准备挑战一个副本，他的角色拥有 x 点生命值，boss 每第 y 秒攻击一次，每次对角色造成1点伤害，当角色生命值为零时游戏结束，不会再受到攻击。现在给你一个时间段，假如小A从这个时间段开始时着手攻略副本，小A想知道他的角色在这段时间内会承受多少次攻击，以及最后一次被攻击的时间。</p></blockquote><p><em><strong>输入格式</strong></em><br>第一行两个整数 x 和 y(1&lt;=x,y&lt;=100) ，由空格隔开。<br>下面两行两个时间，格式为XX:XX:XX ，代表给定的时间段的开始和结束时间。<br>数据保证时间合法，且开始时间和结束时间在同一天</p><p><em><strong>输出格式</strong></em><br>输出共两行：<br>第一行为小A的角色承受boss攻击的次数<br>第二行一个时间，代表小A的角色最后一次遭受攻击的时间，格式为XX:XX:XX</p><p><strong>样例输入</strong><br>5 60<br>18:00:00<br>18:04:30<br><strong>样例输出</strong><br>4<br>18:04:00<br><strong>样例说明</strong><br>如样例，boss 每第 60 秒攻击一次，角色第一次受到攻击时 18：01：00，最后一次是18：04：00 。共承受 4 次攻击。</p><pre class="line-numbers language-none"><code class="language-none">int miao(int t11,int t22,int t33)&#123;    int miaouu&#x3D;t33+t22*60+t11*3600;    return miaouu;&#125;void biao(int ress)&#123;    int h&#x3D;0,m&#x3D;0,s&#x3D;0;    while(ress&gt;&#x3D;3600)&#123;         h++;         ress-&#x3D;3600;    &#125;    while(ress&gt;&#x3D;60)&#123;         m++;         ress-&#x3D;60;    &#125;        s&#x3D;ress;    printf(&quot;%02d:%02d:%02d&quot;,h,m,s);&#125;int main()&#123;    int x,y,t1,t2,t3,tt1,tt2,tt3,time1,time2,num&#x3D;0;    scanf(&quot;%d%d&quot;,&amp;x,&amp;y);    scanf(&quot;%d:%d:%d&quot;,&amp;t1,&amp;t2,&amp;t3);    scanf(&quot;%d:%d:%d&quot;,&amp;tt1,&amp;tt2,&amp;tt3);    time1&#x3D;miao(t1,t2,t3);    time2&#x3D;miao(tt1,tt2,tt3);    int time&#x3D;time2-time1;    while(time&gt;&#x3D;y&amp;&amp;x&gt;0)&#123;        num++;        time-&#x3D;y;        time1+&#x3D;y;        x--;    &#125;    printf(&quot;%d\n&quot;,num);    biao(time1);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-8-去掉重复的数据"><a href="#1-8-去掉重复的数据" class="headerlink" title="1-8 去掉重复的数据"></a>1-8 去掉重复的数据</h2><blockquote><p>在一大堆数据中找出重复的是一件经常要做的事情。现在，我们要处理许多整数，在这些整数中，可能存在重复的数据。你要写一个程序来做这件事情，读入数据，检查是否有重复的数据。如果有，去掉所有重复的数字。最后按照输入顺序输出没有重复数字的数据。所有重复的数字只保留第一次出现的那份。</p></blockquote><p><em><strong>输入格式:</strong></em><br>你的程序首先会读到一个正整数 n，1≤n≤100000。<br>然后是 n 个整数，这些整数的范围是 [1, 100000]。</p><p><em><strong>输出格式:</strong></em><br>在一行中按照输入顺序输出去除重复之后的数据。每两个数据之间有一个空格，行首尾不得有多余空格。</p><p><strong>输入样例:</strong><br>5<br>1 2 2 1 4<br><strong>输出样例:</strong><br>1 2 4</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,x,arr[100005]&#x3D;&#123;0&#125;,num&#x3D;1;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;x);        if(arr[x]&#x3D;&#x3D;0&amp;&amp;num)&#123;            printf(&quot;%d&quot;,x);            num&#x3D;0;        &#125;        else if(arr[x]&#x3D;&#x3D;0)&#123;            printf(&quot; %d&quot;,x);        &#125;        arr[x]++;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典题目</title>
      <link href="/2022/12/09/%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/12/09/%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>这里记录了一些让我在做题时遇见的自感比较经典且容易出错的题目。</p><h1 id="数组元素循环右移问题"><a href="#数组元素循环右移问题" class="headerlink" title="数组元素循环右移问题"></a>数组元素循环右移问题</h1><blockquote><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将最后M个数循环移至最前面的M个位置。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p></blockquote><p><em><strong>输入格式:</strong></em><br>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。</p><p><em><strong>输出格式:</strong></em><br>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><p><strong>输入样例:</strong><br>6 2<br>1 2 3 4 5 6<br><strong>输出样例:</strong><br>5 6 1 2 3 4</p><p><mark>这是我原来的代码<mark>：</mark></mark></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;&#x2F;&#x2F;我的方法是让所有的数组向后移动，再讲最后的几个挪到前面来int main()&#123;int m,n;scanf(&quot;%d%d&quot;,&amp;m,&amp;n);int arr[m];for(int i&#x3D;0;i&lt;m;i++)&#123;scanf(&quot;%d&quot;,&amp;arr[i]);&#125;for(int i&#x3D;0;i&lt;n;i++)&#123;int x&#x3D;arr[m-1];for(int j&#x3D;0;j&lt;&#x3D;m;j++)&#123;arr[m-j]&#x3D;arr[m-j-1];&#125;arr[0]&#x3D;x;&#125;for(int i&#x3D;0;i&lt;m;i++)&#123;printf(&quot;%d&quot;,arr[i]);if(i!&#x3D;m-1)            printf(&quot; &quot;); &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark>这是老师的代码<mark>：</mark></mark></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;通过取余的方式处理数据并直接输出，省时省力！#include &lt;stdio.h&gt;int main() &#123;    int i,n,k,arr[101];    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    for(i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);    &#125;    k&#x3D;k%n;    &#x2F;&#x2F;防止右移长度超过数组长度    for(i&#x3D;n-k;i&lt;n-k+n;i++)&#123;        if(i&#x3D;&#x3D;n-k)            printf(&quot;%d&quot;,arr[i%n]);        else            printf(&quot; %d&quot;,arr[i%n]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="最长字符子串"><a href="#最长字符子串" class="headerlink" title="最长字符子串"></a>最长字符子串</h1><blockquote><p>对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定<strong>Is PAT&amp;TAP symmetric?<strong>，最长对称子串为</strong>s PAT&amp;TAP s</strong>，于是你应该输出<strong>11</strong>。</p></blockquote><p><em><strong>输入格式：</strong></em><br>输入在一行中给出长度不超过1000的非空字符串。<br><em><strong>输出格式：</strong></em><br>在一行中输出最长对称子串的长度。</p><p><strong>输入样例：</strong><br>Is PAT&amp;TAP symmetric?<br><strong>输出样例：</strong><br>11</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123;    int i,k,len,max&#x3D;0;    char arr[1005];    gets(arr);    for(i&#x3D;0;arr[i]!&#x3D;&#39;\0&#39;;i++)&#123;        k&#x3D;1;        len&#x3D;1;        while(i&gt;&#x3D;k&amp;&amp;arr[i+k]!&#x3D;&#39;\0&#39;&amp;&amp;arr[i-k]&#x3D;&#x3D;arr[i+k])&#123;             &#x2F;&#x2F;不是第一个数据&amp;&amp;不越界&amp;&amp;前后相等（奇数情况）            len+&#x3D;2;            k++;        &#125;        if(len&gt;max)            max&#x3D;len;        k&#x3D;1;        len&#x3D;0;        while(i+1&gt;&#x3D;k&amp;&amp;arr[i+k]!&#x3D;&#39;\0&#39;&amp;&amp;arr[i-k+1]&#x3D;&#x3D;arr[i+k])&#123;            &#x2F;&#x2F;不越界&amp;&amp;前后相等（偶数情况）            len+&#x3D;2;            k++;        &#125;        if(len&gt;max)            max&#x3D;len;    &#125;    printf(&quot;%d&quot;,max);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="切割绳子"><a href="#切割绳子" class="headerlink" title="切割绳子"></a>切割绳子</h1><blockquote><p>现有 N 条绳子，它们的长度分别为 L1、L2、L3、L4······，如果从它们中切割出 K 条长度相同的绳子，这 K 条绳子每条最长能有多长?</p></blockquote><p><em><strong>输入格式:</strong></em><br>第一行两个整数n和k（1&lt;n&lt;10000;1&lt;k&lt;10000）。<br>接下来n行，描述了每条绳子的长度L,L也是整数。</p><p><em><strong>输出格式:</strong></em><br>切割后每条绳子的最大长度。</p><p><strong>输入样例:</strong><br>4 11<br>802<br>743<br>457<br>539<br><strong>输出样例:</strong><br>200</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>22级天梯赛热身心得</title>
      <link href="/2022/12/08/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%83%AD%E8%BA%AB%E5%BF%83%E5%BE%97/"/>
      <url>/2022/12/08/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%83%AD%E8%BA%AB%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>今天在打完热身赛补题时发现一处以前没注意到的地方，白白浪费了两个小时进行debug，这里记录一下：</p><h2 id="2-1-有理数均值"><a href="#2-1-有理数均值" class="headerlink" title="2-1 有理数均值"></a>2-1 有理数均值</h2><blockquote><p>本题要求编写程序，计算N个有理数的平均值。<br>输入格式：输入第一行给出正整数N（≤100）；第二行中按照a1/b1 a2/b2 …的格式给出N个分数形式的有理数，其中分子和分母全是整形范围内的整数；如果是负数，则负号一定出现在最前面。<br>输出格式：在一行中按照a/b的格式输出N个有理数的平均值。注意必须是该有理数的最简分数形式，若分母为1，则只输出分子。</p></blockquote><p><strong>输入样例1：</strong><br>4<br>1/2 1/6 3/6 -5/10<br><strong>输出样例1：</strong><br>1/6<br><strong>输入样例2：</strong><br>2<br>4/3 2/3<br><strong>输出样例2：</strong><br>1</p><pre class="line-numbers language-none"><code class="language-none">int gcd(int x,int y);int main()&#123;    int n,fenzi&#x3D;0,fenmu&#x3D;1,up,down,i;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&#x2F;%d&quot;,&amp;up,&amp;down);        if(up&#x3D;&#x3D;0)            continue;        fenzi&#x3D;up*fenmu+fenzi*down;   &#x2F;&#x2F;分子接收数据        fenmu*&#x3D;down;   &#x2F;&#x2F;分母接收数据        if(i&#x3D;&#x3D;n-1)            fenmu*&#x3D;n;   &#x2F;&#x2F;求平均数则 分母*n        int max_gongyue&#x3D;gcd(fenzi,fenmu);   &#x2F;&#x2F;约分        fenzi&#x2F;&#x3D;max_gongyue;        fenmu&#x2F;&#x3D;max_gongyue;    &#125;    if(fenzi&#x3D;&#x3D;0)printf(&quot;0&quot;);else if(fenmu&#x3D;&#x3D;1)        printf(&quot;%d&quot;,fenzi);elseprintf(&quot;%d&#x2F;%d&quot;,fenzi,fenmu);    return 0;&#125;int gcd(int x,int y)&#123;    if(y&#x3D;&#x3D;0)        return x;    else        return gcd(y,x%y);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-伙伴"><a href="#3-2-伙伴" class="headerlink" title="3-2 伙伴"></a>3-2 伙伴</h2><blockquote><p>近来，程序社团开始“创客”——用程序来开发一种“找伙伴的数字游戏”。这个伙伴游戏将玩家分为A和B二组。每组每个玩家可以得到一个数字号码。<br>游戏规则是这样的：A组里的每个人的数字与B组里每个人的数字进行“数字配对”——即加法运算，若运算的结果恰巧是B组内其他玩家手捏的数字号码，那么游戏就可以累计一个分值，这个分值就是B组内这个“恰巧”的数字号码。当然，在B组内“恰巧”的数字号码可能不止一个，游戏允许再次累计。<br>比如加法运算后的“恰巧”的数字是3，而B组内共有2个玩家捏有此数字，那么本组就可以得到6分。<br>你是游戏的开发者之一，你需要迅速计算出找伙伴游戏的最终得分。<br><em><strong>输入格式:</strong></em><br>第一行有二个数字n和m，分别表示A组和B组的人数。<br>第二行有n个整数ai，每个整数之间有一个空格，表示n个玩家手中的数字号码。<br>第三行有m个整数bi，每个整数之间有一个空格，表示m个玩家手中的数字号码。</p></blockquote><p><em><strong>输出格式:</strong></em><br>只有一行，一个数字s，表示游戏的最终分数。</p><p><strong>输入样例1:</strong><br>3 3<br>3 5 6<br>2 7 4<br><strong>输出样例1:</strong><br>14<br><strong>样例说明：</strong><br>A组内捏有”3”的玩家与B组内三个玩家进行“数字配对”，遇4时相加后, 发现B组内有一个恰巧的数字“7”;<br>A组内捏有“5”的玩家与B组内三个玩家进行“数字配对”，遇2相加后, 发现B组内有一个恰巧的数字“7”;<br>当A组内捏有“6”的玩家与B组内三个玩家进行“数字配对”，无论与谁的数字相加，都没有在B组发现一个恰巧的数字;<br>因此最终结果是：7+7=14。</p><p><strong>输入样例2:</strong><br>3 3<br>2 5 2<br>6 8 8<br><strong>输出样例2:</strong><br>32<br><strong>样例说明：</strong><br>A组第1玩家捏有数字”2”,与B组进行“数字配对”时，得分8+8;<br>A组第2玩家捏有数字”5”，与B组进行“数字配对”时，得分0;<br>A组第3玩家捏有数字”2”，与B组进行“数字配对”时，得分8+8;<br>因此最终得分为：8+8+8+8。</p><p><strong>【数据规模】</strong><br>30%的数据，1&lt;=n,m&lt;=3，1&lt;=ai,bi&lt;=100<br>50%数据，1&lt;=n,m&lt;=100，1&lt;=ai,bi&lt;=100<br>70%数据，1&lt;=n,m&lt;=10000，1&lt;=ai,bi&lt;=100<br>100%数据，1&lt;=n,m&lt;=100000，1&lt;=ai,bi&lt;=100</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int m,n,x,y;    long long sum&#x3D;0;    scanf(&quot;%d %d&quot;,&amp;m,&amp;n);    int arr[100000]&#x3D;&#123;0&#125;,brr[100000]&#x3D;&#123;0&#125;;    for(int i&#x3D;0;i&lt;m;i++)&#123;        scanf(&quot;%d&quot;,&amp;x);        arr[x]++;    &#125;    for(int i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;y);        brr[y]++;    &#125;    for(int i&#x3D;1;i&lt;&#x3D;100;i++)&#123;        for(int j&#x3D;1;i+j&lt;&#x3D;100;j++)&#123;            if(arr[i]&gt;0&amp;&amp;brr[j]&gt;0&amp;&amp;brr[i+j]&gt;0)&#123;                sum+&#x3D;arr[i]*brr[j]*brr[i+j]*(i+j);                   &#x2F;&#x2F;A中符合条件的卡片数*B中符合条件的卡片数*B拿到正确结果的人数*（应得的分数）            &#125;        &#125;    &#125;    printf(&quot;%lld&quot;,sum);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h2 id="1-1-重要的话说三遍"><a href="#1-1-重要的话说三遍" class="headerlink" title="1-1 重要的话说三遍"></a>1-1 重要的话说三遍</h2><blockquote><p>这道超级简单的题目没有任何输入。你只需要把这句很重要的话 —— “I’m gonna WIN!”——连续输出三遍就可以了。注意每遍占一行，除了每行的回车不能有任何多余字符。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    for(int i&#x3D;0;i&lt;3;i++)&#123;        printf(&quot;I&#39;m gonna WIN!&quot;);        if(i!&#x3D;2)            printf(&quot;\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-整数积"><a href="#1-2-整数积" class="headerlink" title="1-2 整数积"></a>1-2 整数积</h2><blockquote><p>小明没带草稿纸，心算搞不定整数的乘积，只有请你帮忙设计程序来求输入的任意三个整数的乘积。</p></blockquote><p><em><strong>输入格式:</strong></em><br>输入三个由空格隔开的整数a,b,c，(-1000 &lt; a , b , c &lt; 1000 )</p><p><em><strong>输出格式:</strong></em><br>输出三个整数的乘积</p><p><strong>输入样例:</strong><br>1 2 3<br><strong>输出样例:</strong><br>6</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    long long a,b,c,d;    scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);    d&#x3D;a*b*c;    printf(&quot;%lld&quot;,d);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-三天打鱼两天晒网"><a href="#1-3-三天打鱼两天晒网" class="headerlink" title="1-3 三天打鱼两天晒网"></a>1-3 三天打鱼两天晒网</h2><blockquote><p>中国有句俗语叫“三天打鱼两天晒网”。假设某人从某天起，开始“三天打鱼两天晒网”，问这个人在以后的第N天中是“打鱼”还是“晒网”？</p></blockquote><ul><li>以5为一个循环，然后正常判断即可</li></ul><p><em><strong>输入格式：</strong></em><br>输入在一行中给出一个不超过1000的正整数N。</p><p><em><strong>输出格式：</strong></em><br>在一行中输出此人在第N天中是“Fishing”（即“打鱼”）还是“Drying”（即“晒网”），并且输出“in day N”。</p><p><strong>输入样例1：</strong><br>103<br><strong>输出样例1：</strong><br>Fishing in day 103<br><strong>输入样例2：</strong><br>34<br><strong>输出样例2：</strong><br>Drying in day 34</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,x;    scanf(&quot;%d&quot;,&amp;n);    x&#x3D;n%5;    if(x&gt;0&amp;&amp;x&lt;&#x3D;3)        printf(&quot;Fishing in day %d&quot;,n);    else        printf(&quot;Drying in day %d&quot;,n);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-用天平找小球"><a href="#1-4-用天平找小球" class="headerlink" title="1-4 用天平找小球"></a>1-4 用天平找小球</h2><blockquote><p>三个球A、B、C，大小形状相同且其中有一个球与其他球重量不同。要求找出这个不一样的球。</p></blockquote><p><em><strong>输入格式：</strong></em><br>输入在一行中给出3个正整数，顺序对应球A、B、C的重量。</p><p><em><strong>输出格式：</strong></em><br>在一行中输出唯一的那个不一样的球。</p><p><strong>输入样例：</strong><br>1 1 2<br><strong>输出样例：</strong><br>C</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int a,b,c;    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);    if(a&#x3D;&#x3D;b)        printf(&quot;C&quot;);    else if(a&#x3D;&#x3D;c)        printf(&quot;B&quot;);    else if(b&#x3D;&#x3D;c)        printf(&quot;A&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-100以内的加法"><a href="#1-5-100以内的加法" class="headerlink" title="1-5 100以内的加法"></a>1-5 100以内的加法</h2><blockquote><p>小明刚上小学一年级，数学老师刚刚教会了100以内的整数加法运算，数学老师期中测试出了一道题，题目为求两个整数之间的所有整数之和，包括边界整数值，小明很是为难？现要你编程帮小明解决问题。</p></blockquote><p><em><strong>输入格式:</strong></em><br>在一行中输入两个边界整数值m,n(1&lt;= m &lt;= n &lt;=100)，中间以空格隔开。</p><p><em><strong>输出格式:</strong></em><br>在一行中输出m到n之间的所有整数和。</p><p><strong>输入样例:</strong><br>2 7<br><strong>输出样例:</strong><br>27</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int a,b,sum&#x3D;0;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    for(int i&#x3D;a;i&lt;&#x3D;b;i++)&#123;        sum+&#x3D;i;    &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-6-循环的统计"><a href="#1-6-循环的统计" class="headerlink" title="1-6 循环的统计"></a>1-6 循环的统计</h2><blockquote><p>在墙角堆放着一堆完全相同的正方体小木块，从上往下数起，第一层是1块，第二层是3块，第三层是6块…… 因为木块堆得实在是太有规律了，你只要知道它的层数就可以计算所有木块的数量了。<br><img src="/2022/12/08/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%83%AD%E8%BA%AB%E5%BF%83%E5%BE%97/0001.png" alt="题目图片"></p></blockquote><ul><li>观察可得，第i层比上一层多了i个方块。</li></ul><p><em><strong>输入格式:</strong></em><br>只有一个整数 n ，表示这堆小木块的层数，已知1 &lt;= n &lt;= 100 。</p><p><em><strong>输出格式:</strong></em><br>只有一个整数，表示这堆小木块的总数量。</p><p><strong>输入样例:</strong><br>5<br><strong>输出样例:</strong><br>35</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,sum1&#x3D;0,sum&#x3D;0;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;        sum1+&#x3D;i;        sum+&#x3D;sum1;    &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-7-求特殊方程的正整数解"><a href="#1-7-求特殊方程的正整数解" class="headerlink" title="1-7 求特殊方程的正整数解"></a>1-7 求特殊方程的正整数解</h2><blockquote><p>本题要求对任意给定的正整数N，求方程X^2+Y^2=N的全部正整数解。</p></blockquote><ul><li>数据较小，嵌套枚举即可</li></ul><p><em><strong>输入格式：</strong></em><br>输入在一行中给出正整数N（≤10000）。</p><p><em><strong>输出格式：</strong></em><br>输出方程X^2+Y^2=N的全部正整数解，其中X≤Y。每组解占1行，两数字间以1空格分隔，按X的递增顺序输出。如果没有解，则输出No Solution。</p><p><strong>输入样例1：</strong><br>884<br><strong>输出样例1：</strong><br>10 28<br>20 22<br><strong>输入样例2：</strong><br>11<br><strong>输出样例2：</strong><br>No Solution</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,flag&#x3D;0;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;&#x3D;sqrt(n);i++)&#123;        for(int j&#x3D;0;j&lt;sqrt(n);j++)&#123;            if(i*i+j*j&#x3D;&#x3D;n&amp;&amp;i&lt;&#x3D;j)&#123;                printf(&quot;%d %d\n&quot;,i,j);                flag&#x3D;1;            &#125;        &#125;    &#125;    if(!flag)&#123;        printf(&quot;No Solution&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-8-猜数字游戏"><a href="#1-8-猜数字游戏" class="headerlink" title="1-8 猜数字游戏"></a>1-8 猜数字游戏</h2><blockquote><p>猜数字游戏是令游戏机随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Too big”），还是小了（“Too small”），相等表示猜到了。如果猜到，则结束程序。程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo!”；如果3次以内猜到该数，则提示“Lucky You!”；如果超过3次但是在N（&gt;3）次以内（包括第N次）猜到该数，则提示“Good Guess!”；如果超过N次都没有猜到，则提示“Game Over”，并结束程序。如果在到达N次之前，用户输入了一个负数，也输出“Game Over”，并结束程序。</p></blockquote><ul><li>看着唬人其实很普通的一道题，准确处理好每个变量关系即可</li></ul><p><em><strong>输入格式:</strong></em><br>输入第一行中给出两个不超过100的正整数，分别是游戏机产生的随机数、以及猜测的最大次数N。最后每行给出一个用户的输入，直到出现负数为止。</p><p><em><strong>输出格式:</strong></em><br>在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。</p><p><strong>输入样例:</strong><br>58 4<br>70<br>50<br>56<br>58<br>60<br>-2</p><p><strong>输出样例:</strong><br>Too big<br>Too small<br>Too small<br>Good Guess!</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,t,x,flag&#x3D;0,num&#x3D;0;    scanf(&quot;%d %d&quot;,&amp;n,&amp;t);    while(scanf(&quot;%d&quot;,&amp;x)!&#x3D;EOF)&#123;        num++;        if((num&lt;&#x3D;t&amp;&amp;x&lt;0)||(num&gt;t))&#123;            printf(&quot;Game Over\n&quot;);            break;        &#125;        if(x&gt;n)&#123;            printf(&quot;Too big\n&quot;);            flag++;        &#125;        else if(x&lt;n)&#123;            printf(&quot;Too small\n&quot;);            flag++;        &#125;        else&#123;            if(flag&#x3D;&#x3D;0)&#123;                printf(&quot;Bingo!\n&quot;);                break;            &#125;            else if(flag&lt;&#x3D;2&amp;&amp;flag&gt;&#x3D;1)&#123;                printf(&quot;Lucky You!\n&quot;);                break;            &#125;            else if(flag&gt;2&amp;&amp;flag&lt;t)&#123;                printf(&quot;Good Guess!\n&quot;);                break;            &#125;            else&#123;                printf(&quot;Game Over\n&quot;);                break;            &#125;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="进阶题"><a href="#进阶题" class="headerlink" title="进阶题"></a>进阶题</h1><h2 id="2-1-有理数均值-1"><a href="#2-1-有理数均值-1" class="headerlink" title="2-1 有理数均值"></a>2-1 有理数均值</h2><ul><li>见文章开头</li></ul><h2 id="2-2-求矩阵的局部极大值"><a href="#2-2-求矩阵的局部极大值" class="headerlink" title="2-2 求矩阵的局部极大值"></a>2-2 求矩阵的局部极大值</h2><blockquote><p>给定M行N列的整数矩阵A，如果A的非边界元素A[i][j]大于相邻的上下左右4个元素，那么就称元素A[i][j]是矩阵的局部极大值。本题要求给定矩阵的全部局部极大值及其所在的位置。</p></blockquote><ul><li>找的时候舍弃二维数组的最外一层，判断与四周的关系即可</li></ul><p><em><strong>输入格式：</strong></em><br>输入在第一行中给出矩阵A的行数M和列数N（3≤M,N≤20）；最后M行，每行给出A在该行的N个元素的值。数字间以空格分隔。</p><p><em><strong>输出格式：</strong></em><br>每行按照“元素值 行号 列号”的格式输出一个局部极大值，其中行、列编号从1开始。要求按照行号递增输出；若同行有超过1个局部极大值，则该行按列号递增输出。若没有局部极大值，则输出“None 总行数 总列数”。</p><p><strong>输入样例1：</strong><br>4 5<br>1 1 1 1 1<br>1 3 9 3 1<br>1 5 3 5 1<br>1 1 1 1 1<br><strong>输出样例1：</strong><br>9 2 3<br>5 3 2<br>5 3 4<br><strong>输入样例2：</strong><br>3 5<br>1 1 1 1 1<br>9 3 9 9 1<br>1 5 3 5 1<br><strong>输出样例2：</strong><br>None 3 5</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int m,n,flag&#x3D;1;    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    int arr[m+1][n+1];    for(int i&#x3D;0;i&lt;m;i++)&#123;        for(int j&#x3D;0;j&lt;n;j++)&#123;            scanf(&quot;%d&quot;,&amp;arr[i][j]);        &#125;    &#125;    for(int i&#x3D;1;i&lt;m-1;i++)&#123;        for(int j&#x3D;1;j&lt;n-1;j++)&#123;            if((arr[i][j]&gt;arr[i-1][j])&amp;&amp;(arr[i][j]&gt;arr[i][j-1])&amp;&amp;(arr[i][j]&gt;arr[i+1][j])&amp;&amp;(arr[i][j]&gt;arr[i][j+1]))&#123;                printf(&quot;%d %d %d\n&quot;,arr[i][j],i+1,j+1);                flag&#x3D;0;            &#125;        &#125;    &#125;    if(flag)&#123;        printf(&quot;None %d %d&quot;,m,n);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-傻傻分不清楚"><a href="#2-3-傻傻分不清楚" class="headerlink" title="2-3 傻傻分不清楚"></a>2-3 傻傻分不清楚</h2><blockquote><p>有一次小Y的键盘的大写键坏了（打字母随机大小写），但他现在需要照着打几段字符串（只有英文字母），不过他有时候会有点粗心会打错字母。然后现在我需要眼尖的你来帮帮我帮我找出他有没有粗心（只是大小写不同不算粗心），如果没有请你告诉我键盘一共坏了几次。</p></blockquote><ul><li>记得更新数组即可</li></ul><p><em><strong>输入格式:</strong></em><br>输入第一行给出正整数N，代表他接下来要打的字符串数量。<br>随后给出2N行字符串，两两对应。<br>每段字符串长度小于100。本题多组数据。</p><p><em><strong>输出格式:</strong></em><br>每两个字符串输出一行，如果他粗心了输出“NO!”，没有粗心输出“YES!”并在后面空一格输出键盘坏的次数</p><p><strong>输入样例:</strong><br>在这里给出一组输入。例如：<br>2<br>abcdfef<br>aBCdfef<br>c<br>c<br>1<br>qwer<br>QEWr<br><strong>输出样例:</strong><br>在这里给出相应的输出。例如：<br>YES! 2<br>YES! 0<br>NO!</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,flag&#x3D;0,i;    char arr[105],brr[105];    while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;        scanf(&quot;%s%s&quot;,arr,brr);        for(i&#x3D;0;i&lt;strlen(arr);i++)&#123;                if((arr[i]&#x3D;&#x3D;brr[i]))                    continue;                else if((arr[i]-32&#x3D;&#x3D;brr[i])||(arr[i]+32&#x3D;&#x3D;brr[i]))&#123;                    flag++;                    continue;                &#125;                else&#123;                    printf(&quot;NO!\n&quot;);                    break;                &#125;        &#125;        if(i&#x3D;&#x3D;strlen(arr))&#123;            printf(&quot;YES! %d\n&quot;,flag);        &#125;        for(i&#x3D;0;i&lt;strlen(arr);i++)&#123;   &#x2F;&#x2F;记得更新数组            arr[i]&#x3D;0;            brr[i]&#x3D;0;        &#125;        flag&#x3D;0;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-谁先倒"><a href="#2-4-谁先倒" class="headerlink" title="2-4 谁先倒"></a>2-4 谁先倒</h2><blockquote><p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。下面给出甲、乙两人的酒量（最多能喝多少杯不倒）和划拳记录，请你判断两个人谁先倒。</p></blockquote><ul><li>注意同输同赢时不要处理数据</li></ul><p><em><strong>输入格式：</strong></em><br>输入第一行先后给出甲、乙两人的酒量（不超过100的非负整数），以空格分隔。下一行给出一个正整数N（≤100），随后N行，每行给出一轮划拳的记录，格式为：<br><strong>甲喊 甲划 乙喊 乙划</strong><br>其中喊是喊出的数字，划是划出的数字，均为不超过100的正整数（两只手一起划）。</p><p><em><strong>输出格式：</strong></em><br>在第一行中输出先倒下的那个人：A代表甲，B代表乙。第二行中输出没倒的那个人喝了多少杯。题目保证有一个人倒下。注意程序处理到有人倒下就终止，后面的数据不必处理。</p><p><strong>输入样例：</strong><br>1 1<br>6<br>8 10 9 12<br>5 10 5 10<br>3 8 5 12<br>12 18 1 13<br>4 16 12 15<br>15 1 1 16<br><strong>输出样例：</strong><br>A<br>1</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int m,n,t,jh,jhw,yh,yhw,flag1&#x3D;0,flag2&#x3D;0;    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        scanf(&quot;%d%d%d%d&quot;,&amp;jh,&amp;jhw,&amp;yh,&amp;yhw);        if(jhw&#x3D;&#x3D;jh+yh&amp;&amp;yhw!&#x3D;jh+yh)&#123;            flag1++;            &#125;        if(yhw&#x3D;&#x3D;jh+yh&amp;&amp;jhw!&#x3D;jh+yh)&#123;            flag2++;        &#125;        if(flag1&gt;m)&#123;            printf(&quot;A\n%d&quot;,flag2);            break;        &#125;        if(flag2&gt;n)&#123;            printf(&quot;B\n%d&quot;,flag1);            break;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="登顶题"><a href="#登顶题" class="headerlink" title="登顶题"></a>登顶题</h1><h2 id="3-1-帅到没朋友"><a href="#3-1-帅到没朋友" class="headerlink" title="3-1 帅到没朋友"></a>3-1 帅到没朋友</h2><blockquote><p>当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。</p></blockquote><ul><li>当输入人数为1时不要处理，输出时注意5位格式！</li></ul><p><em><strong>输入格式：</strong></em><br>输入第一行给出一个正整数N（≤100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（≤10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。</p><p>注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。</p><p><strong>输出格式：</strong><br>按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出No one is handsome。</p><p><strong>注意：同一个人可以被查询多次，但只输出一次。</strong></p><p><strong>输入样例1：</strong><br>3<br>3 11111 22222 55555<br>2 33333 44444<br>4 55555 66666 99999 77777<br>8<br>55555 44444 10000 88888 22222 11111 23333 88888<br><strong>输出样例1：</strong><br>10000 88888 23333<br><strong>输入样例2：</strong><br>3<br>3 11111 22222 55555<br>2 33333 44444<br>4 55555 66666 99999 77777<br>4<br>55555 44444 22222 11111<br><strong>输出样例2：</strong><br>No one is handsome</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,x,y,t,num,flag&#x3D;1;    int arr[100000]&#x3D;&#123;0&#125;;    scanf(&quot;%d&quot;,&amp;n);    for(int j&#x3D;0;j&lt;n;j++)&#123;        scanf(&quot;%d&quot;,&amp;x);        for(int i&#x3D;0;i&lt;x;i++)&#123;            scanf(&quot;%d&quot;,&amp;y);            if(x!&#x3D;1)            arr[y]++;        &#125;    &#125;    scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        scanf(&quot;%d&quot;,&amp;num);        if(arr[num]&#x3D;&#x3D;0)&#123;            flag&#x3D;0;            printf(&quot;%05d&quot;,num);            if(t&gt;1)                printf(&quot; &quot;);            arr[num]&#x3D;1;        &#125;    &#125;    if(flag)            printf(&quot;No one is handsome&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-伙伴-1"><a href="#3-2-伙伴-1" class="headerlink" title="3-2 伙伴"></a>3-2 伙伴</h2><ul><li>见文章开头</li></ul><h2 id="3-3-密文游戏"><a href="#3-3-密文游戏" class="headerlink" title="3-3 密文游戏"></a>3-3 密文游戏</h2><blockquote><p>JLU最近流行密文游戏。发送者把信息（原文）按约定的规则变成密文发给接收者,接收者拿到密文按解密规则得到原文。其它人不知道加密解密规则，即使拿到信息的密文，也无法得知原文。<br>小明是你的好朋友，想和你一起玩密文游戏。你俩约定了一个简单的加密解密方案：字符 0 映射字母 A，字符 1 映射字母 B，依次类推，字符 9 映射字母 J。例如：原文1314的密文为BDBE。<br>昨天，你给小明发了一条信息。由于未知原因，密文到小明那里发生了缺失。今天上课，你俩见面对照了原文和密文，发现密文丢失了若干字符。设原文S的长度为n，密文T的长度为m，小明突发奇想：对照原文，有多少种方案能把密文补全，字母数量和位置不同，都视为不同的方案。作为好友的你,帮他计算一下吧。</p></blockquote><p><em><strong>输入格式:</strong></em><br>第一行，原文S，长度为n(2≤n≤2000)。<br>第二行，密文T，长度为m(1≤m ≤ n-1 )。</p><p><em><strong>输出格式:</strong></em><br>一行，所求的方案数</p><p><strong>输入样例:</strong><br>在这里给出一组输入。例如：<br>1414<br>BE<br><strong>输出样例:</strong><br>在这里给出相应的输出。例如：<br>3<br><strong>样例说明</strong><br>样例中3种补全方案如下。（）中代表所补的密文。<br>BE(BE)<br>B(EB)E<br>(BE)BE</p><p><em><strong>解析还未出炉，先看看别的吧~</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制转换</title>
      <link href="/2022/12/04/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2022/12/04/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="十进制转d进制-d-lt-10"><a href="#十进制转d进制-d-lt-10" class="headerlink" title="十进制转d进制(d&lt;10)"></a>十进制转d进制(d&lt;10)</h2><p>原理很简单，按照计算方法算出每一位后存入数组，倒序输出即可~</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;  int n,i&#x3D;0,x,j,d;  int arr[1000];  scanf(&quot;%d%d&quot;,&amp;n,&amp;d);  if(n&#x3D;&#x3D;0)    printf(&quot;0&quot;);  else&#123;  while(n&gt;0)&#123;        &#x2F;&#x2F;想不起来的话把d设成2自己代入一遍    x&#x3D;n%d;    n&#x2F;&#x3D;d;    arr[i]&#x3D;x;    i++;  &#125;  for(j&#x3D;i-1;j&gt;&#x3D;0;j--)&#123;    &#x2F;&#x2F;逆序输出    printf(&quot;%d&quot;,arr[j]);  &#125;  &#125;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="d进制转十进制（d-lt-10"><a href="#d进制转十进制（d-lt-10" class="headerlink" title="d进制转十进制（d&lt;10)"></a>d进制转十进制（d&lt;10)</h2><pre class="line-numbers language-none"><code class="language-none">int main()&#123;  int n,x&#x3D;1,num&#x3D;0,d;  scanf(&quot;%d%d&quot;,&amp;n,&amp;d);  while(n&gt;0)&#123;    num+&#x3D;(n%10)*x;    &#x2F;&#x2F;拨出最后一位乘以位权    n&#x2F;&#x3D;10;    &#x2F;&#x2F;舍弃最后一位    x*&#x3D;d;    &#x2F;&#x2F;位权增加  &#125;  printf(&quot;%d&quot;,num);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十进制转十六进制"><a href="#十进制转十六进制" class="headerlink" title="十进制转十六进制"></a>十进制转十六进制</h2><p>与前面的“十进制转d进制”差不多，只是用<em>字符数组</em>代替了<em>整型数组</em></p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;  int n,i&#x3D;0,j;  char arr[1000],brr[20]&#x3D;&#123;&quot;0123456789ABCDEF&quot;&#125;;  scanf(&quot;%d&quot;,&amp;n);  if(n&#x3D;&#x3D;0)    printf(&quot;0&quot;);  else&#123;  while(n&gt;0)&#123;    arr[i]&#x3D;brr[n%16];    n&#x2F;&#x3D;16;    i++;  &#125;  for(j&#x3D;i-1;j&gt;&#x3D;0;j--)&#123;    printf(&quot;%c&quot;,arr[j]);  &#125;  &#125;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>在查找资料的时候发现C艹自带进制转换的函数，顺便记录一下~</p><blockquote><p>oct 是八进制形式<br> dec 是十进制形式<br> hex 是十六进制形式（setiosflags(ios::uppercase)可转换为大写输出）<br>C语言没有专门的二进制转换，故只能规定位数输出二进制</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main() &#123;    int n;    cin&gt;&gt;n;    cout&lt;&lt;bitset&lt;8&gt;(n)&lt;&lt;endl;    cout&lt;&lt;oct&lt;&lt;n&lt;&lt;endl;    cout&lt;&lt;dec&lt;&lt;n&lt;&lt;endl;    cout&lt;&lt;setiosflags(ios::uppercase)&lt;&lt;hex&lt;&lt;n&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归与递推</title>
      <link href="/2022/12/03/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/"/>
      <url>/2022/12/03/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<p>递归与递推是编程问题中重要的思想，如何更好的理解？看完这篇文章你可能会有收获。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h2><blockquote><p>递归，就是在运行的过程中不断调用自己本身。可以分为“递”和“归”两个过程，“递”得到每一个小步的结果，再通过“归”将每次运算的结果结合起来。最后得到答案。</p></blockquote><h2 id="递归优缺点"><a href="#递归优缺点" class="headerlink" title="递归优缺点"></a>递归优缺点</h2><ul><li>优点：代码简解易懂，思维方式符合我们思考的逻辑。</li><li>缺点：运行效率低，需要调用很多栈来储存返回点和局部量等，容易造成栈溢出。</li></ul><h1 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h1><h2 id="递推定义"><a href="#递推定义" class="headerlink" title="递推定义"></a>递推定义</h2><blockquote><p>递推，就是从问题的初始条件出发，通过观察得出某种关系式，通过这个关系式推出各项结果。</p></blockquote><h2 id="递推优缺点"><a href="#递推优缺点" class="headerlink" title="递推优缺点"></a>递推优缺点</h2><ul><li>优点：很好的发挥了计算机重复计算的优点，不会像递推一样占用过多的内存空间。</li><li>缺点：想象不到递推的关系式，从源头上直接gg（doge 。</li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="裴波那契数列"><a href="#裴波那契数列" class="headerlink" title="裴波那契数列"></a>裴波那契数列</h2><blockquote><p>有一对小兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。按此规律，假设没有兔子死亡，第一个月有一对刚出生的小兔子，问第n个月有多少对兔子？</p></blockquote><p>在草稿纸上进行简单的演算，我们会发现:第一个月1对，第二个月1对，第三个月2对，第四个月3对，第五个月5对，第六个月8对，第七个月13对……<strong>从第三项开始，每个月的数量都是前两个月的和</strong></p><p>不难得出，<strong>当n&gt;=3时，本月兔子数量=上个月数量+上上个月数量</strong>。</p><p>递归、递推代码</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;int digui(int n)    &#x2F;&#x2F;递归&#123;    if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)        return 1;    else        return (digui(n-1)+digui(n-2));&#125;int ditui(int n)    &#x2F;&#x2F;递推&#123;    int x&#x3D;1,y&#x3D;1,z;    if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)        z&#x3D;1;    else &#123;        for(int i&#x3D;0;i&lt;n-2;i++)&#123;        z&#x3D;x+y;        x&#x3D;y;        y&#x3D;z;        &#125;    &#125;    return z;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;%d\n&quot;,digui(n));    printf(&quot;%d\n&quot;,ditui(n));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高中往事回忆</title>
      <link href="/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/"/>
      <url>/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p><strong>后期会持续推出<del>敬请期待</del></strong></p><p><img src="/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/0000.jpg" alt="和本组的帅哥美女"></p>]]></content>
      
      
      <categories>
          
          <category> 回忆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈各种排序</title>
      <link href="/2022/11/30/%E6%B5%85%E8%B0%88%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/11/30/%E6%B5%85%E8%B0%88%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序是我们在学习编程的过程中经常用的问题，这篇博客会总结一些我比较常用的一些算法，以供复习和回忆。</p><p>比较常见的排序大致分为两种，<strong>比较型排序</strong>和<strong>非比较型排序</strong></p><ul><li>比较型排序将元素之间两两进行比较，<em>比较耗时间</em>。</li><li>非比较型排序将元素进行记录，<em>比较耗空间</em>。</li></ul><p><em><strong>我们通常认为时间比空间重要，故经常使用牺牲空间的方式来减少运行时间</strong></em></p><h2 id="比较型排序"><a href="#比较型排序" class="headerlink" title="比较型排序"></a>比较型排序</h2><h3 id="一、插入排序"><a href="#一、插入排序" class="headerlink" title="一、插入排序"></a>一、插入排序</h3><p>一个无序数列，从左到右每次取一个数向左依次比较，直至左边有一个数比它小，则插入。</p><blockquote><p>时间复杂度：O(N)~O(N<sup>2)<br>空间复杂度：O(1)</sup></p></blockquote><p>代码部分：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;void InsertSort(int arr[],int n)&#123;for(int i&#x3D;0;i&lt;n-1;++i)&#123;  &#x2F;&#x2F;第一个已经排好序，没必要再参与计算        int end&#x3D;i;    &#x2F;&#x2F;记录有序序列当前最后元素的下标        int temp&#x3D;arr[end+1];    &#x2F;&#x2F;待插入的元素        while(end&gt;&#x3D;0)&#123;            if(arr[end]&gt;temp)&#123;                    arr[end+1]&#x3D;arr[end];    &#x2F;&#x2F;比插入的数大就向后移                end--;            &#125;            else                break;    &#x2F;&#x2F;比插入的数小，跳出循环        &#125;        arr[end+1]&#x3D;temp;    &#x2F;&#x2F;放入temp&#125;&#125;int main() &#123;    int arr[20],i,n;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);    &#125;    InsertSort(arr,n);    for(i&#x3D;0;i&lt;n;i++)&#123;        printf(&quot;%d &quot;,arr[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><p>也是我比较喜欢用的一种排序，每次从左到右相邻的元素两两比较，第一个与第二个比较，让大的那个与第三个比较。这样可以使最大的数排在最右边。</p><blockquote><p>时间复杂度：O(N)~O(N<sup>2)<br>空间复杂度：O(1)</sup></p></blockquote><p>代码部分：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;void BubbleSort(int arr[],int n)&#123;    int i,j,temp&#x3D;0;    for(i&#x3D;0;i&lt;n-1;i++)&#123;        for(j&#x3D;i+1;j&lt;n;j++)&#123;            if(arr[i]&gt;arr[j])&#123;                temp&#x3D;arr[i];                arr[i]&#x3D;arr[j];                arr[j]&#x3D;temp;            &#125;        &#125;    &#125;&#125;int main() &#123;    int arr[20],i,n;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);    &#125;    BubbleSort(arr,n);    for(i&#x3D;0;i&lt;n;i++)&#123;        printf(&quot;%d &quot;,arr[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="非比较型排序"><a href="#非比较型排序" class="headerlink" title="非比较型排序"></a>非比较型排序</h2><h3 id="计数排序（Count-sort）"><a href="#计数排序（Count-sort）" class="headerlink" title="计数排序（Count sort）"></a>计数排序（Count sort）</h3><p>计数排序也就是我们刚接触数组时使用的排序方法，快于任何一种比较型排序算法，但条件较为苛刻：<strong>数据范围较小，否则非常浪费空间</strong></p><blockquote><p><strong>k为数组长度</strong><br>时间复杂度就是O(n+k)<br>空间复杂度为O(k)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int main() &#123;    int arr[1000],brr[1000]&#x3D;&#123;0&#125;;    int n,i,j;    scanf(&quot;%d&quot;,&amp;n);    scanf(&quot;%d&quot;,&amp;arr[0]);    brr[arr[0]]++;    int max&#x3D;arr[0];    for(i&#x3D;1;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);        brr[arr[i]]++;        if(arr[i]&gt;max)            max&#x3D;arr[i];    &#125;    for(i&#x3D;0;i&lt;max+1;i++)&#123;        for(j&#x3D;0;j&lt;brr[i];j++)&#123;            printf(&quot;%d &quot;,i);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈二分查找</title>
      <link href="/2022/11/29/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/11/29/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>相信我们都在编程过程中遇见查找问题，而查找的方式有许多种，我们最常见的、也是使用次数最多的便是<em><strong>二分查找</strong></em>了，原理简单且不容易超时。<br>二分查找的思想很容易理解，但大多数人都是通过记模板来使用，这篇博客将二分法做一个大概的总结，以供记忆和复习。</p><h2 id="一、分享小故事"><a href="#一、分享小故事" class="headerlink" title="一、分享小故事"></a>一、分享小故事</h2><p>这里引用了CSDN中<a href="https://blog.csdn.net/qq_45978890/article/details/116094046?spm=1001.2014.3001.5502">Charon_cc</a>的一个很生动形象的例子：</p><hr><blockquote><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1 本书。</p></blockquote><hr><p>多读两遍我们就会发现<mark>二分查找法的前提<mark>：</mark></mark></p><h2 id="二、二分查找的前提"><a href="#二、二分查找的前提" class="headerlink" title="二、二分查找的前提"></a>二、二分查找的前提</h2><ul><li><strong>查找的目标只能有一个</strong></li><li><strong>查找的范围内元素是有序的</strong>（排序在C++里可以直接使用sort，而在C里可以使用冒泡排序等方法）</li></ul><p>为什么是这样的一个前提呢？我们首先应该知道<mark>二分查找的原理<mark>：</mark></mark></p><h2 id="三、二分查找的原理"><a href="#三、二分查找的原理" class="headerlink" title="三、二分查找的原理"></a>三、二分查找的原理</h2><blockquote><p>在一个已经从小到大排好的数组里，先把目标与数组中间值比较<br>* 若目标&gt;中间值，则接着找后半部分，前半部分舍弃。<br>* 若目标&lt;中间值，则接着找前半部分，后半部分舍弃。</p></blockquote><p>那有初学的朋友会问了：<em>数组元素数是偶数的话怎么取中间值？</em></p><p>其实不必纠结这个问题，因为每次都丢掉数组的一半的话，这个问题是一定会出现的。</p><p>虽说叫二分查找，但并不是说我们必须严格的取一半，只是取一半时舍弃掉的不合要求的元素最多，比较节约时间而已。<br>而由于我们使用<strong>int</strong>类型，每次取的就是最中间两个数中靠左的那个，这样一来无非是在搜索的范围里多加一个数而已，只要我们继续进行二分查找并找好边界值，就永远不会有元素被落下。</p><h2 id="四、二分查找的使用"><a href="#四、二分查找的使用" class="headerlink" title="四、二分查找的使用"></a>四、二分查找的使用</h2><p>这里只写我最常用的一种方式：<mark>[left,right]式<mark><br>使用int函数进行运算：</mark></mark></p><pre class="line-numbers language-none"><code class="language-none">int binarysearch(int arr[],int size,int target)&#123;    &#x2F;&#x2F;size 可使用int size&#x3D;sizeof(arr)&#x2F;sizeof(arr[0])计算    int l&#x3D;0,r&#x3D;size-1;   &#x2F;&#x2F;l&#x3D;left,r&#x3D;right,m&#x3D;middle    while(l&lt;&#x3D;r)&#123;        int m&#x3D;l+(r-l)&#x2F;2;    &#x2F;&#x2F;防止直接相加导致溢出        if(arr[m]&gt;target)&#123;            r&#x3D;m-1;        &#125;        else if(arr[m]&lt;target)&#123;            l&#x3D;m+1;        &#125;        else            return m;    &#125;    return -1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、二分查找的性能"><a href="#五、二分查找的性能" class="headerlink" title="五、二分查找的性能"></a>五、二分查找的性能</h2><ul><li>时间复杂度：O(1)~O(log<sub>2</sub>n)</li><li>空间复杂度：O(1)~O(log<sub>2</sub>n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公因数和最小公倍数（欧几里得算法）</title>
      <link href="/2022/11/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
      <url>/2022/11/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>我们在学习时经常性遇见求最大公因数和最小公倍数的问题，而使用枚举的话非常容易超时，那么我们应该怎样更快更好地解决它们呢?</p><span id="more"></span><h2 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>又称<em>辗转相除法</em>，使用int类型的函数实现，两个参数的传入条件要求<em><strong>a大于b</strong></em>。<br><strong>百度百科</strong>：欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。<br>总之就是不断把<em>除数当被除数，余数当除数</em><br>假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：<br>1997 ÷ 615 = 3 (余 152)<br>615 ÷ 152 = 4(余7)<br>152 ÷ 7 = 21(余5)<br>7 ÷ 5 = 1 (余2)<br>5 ÷ 2 = 2 (余1)<br>2 ÷ 1 = 2 (余0)<br>至此，最大公约数为1<br>以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int gcd(int a,int b)&#123;    int t;    if(a&lt;b)&#123;  &#x2F;&#x2F;使大的作被除数        t&#x3D;a;a&#x3D;b;b&#x3D;t;    &#125;    if(b&#x3D;&#x3D;0)  &#x2F;&#x2F;判断是否存在0的情况        return a;    else        return gcd(b,a%b);&#125;int main()&#123;    int a,b;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    printf(&quot;%d&quot;,gcd(a,b));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>相信你已经学会求最大公因数，那么最小公倍数呢？<br><strong>当然也是非常简单滴！</strong><br><em><strong>最小公倍数=（ab）/最大公因数</strong></em></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int gcd(int a,int b)&#123;    int t;    if(a&lt;b)&#123;  &#x2F;&#x2F;使大的作被除数        t&#x3D;a;a&#x3D;b;b&#x3D;t;    &#125;    if(b&#x3D;&#x3D;0)  &#x2F;&#x2F;判断是否存在0的情况        return a;    else        return gcd(b,a%b);&#125;int main()&#123;    int a,b;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    printf(&quot;%d&quot;,(a*b)&#x2F;gcd(a,b));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 求数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>myself</title>
      <link href="/myself/index.html"/>
      <url>/myself/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/messageboard/index.html"/>
      <url>/messageboard/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
