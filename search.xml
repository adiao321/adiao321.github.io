<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>高中往事回忆</title>
      <link href="/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/"/>
      <url>/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/0000.jpg" alt="高中往事回忆"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈各种排序</title>
      <link href="/2022/11/30/%E6%B5%85%E8%B0%88%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/11/30/%E6%B5%85%E8%B0%88%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈二分查找</title>
      <link href="/2022/11/29/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/11/29/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>相信我们都在编程过程中遇见查找问题，而查找的方式有许多种，我们最常见的、也是使用次数最多的便是<em><strong>二分查找</strong></em>了，原理简单且不容易超时。<br>二分查找的思想很容易理解，但大多数人都是通过记模板来使用，这篇博客将二分法做一个大概的总结，以供记忆和复习。</p><h2 id="一、分享小故事"><a href="#一、分享小故事" class="headerlink" title="一、分享小故事"></a>一、分享小故事</h2><p>这里引用了CSDN中<a href="https://blog.csdn.net/qq_45978890/article/details/116094046?spm=1001.2014.3001.5502">Charon_cc</a>的一个很生动形象的例子：</p><hr><blockquote><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1 本书。</p></blockquote><hr><p>多读两遍我们就会发现<mark>二分查找法的前提<mark>：</mark></mark></p><h2 id="二、二分查找的前提"><a href="#二、二分查找的前提" class="headerlink" title="二、二分查找的前提"></a>二、二分查找的前提</h2><ul><li><strong>查找的目标只能有一个</strong></li><li><strong>查找的范围内元素是有序的</strong>（排序在C++里可以直接使用sort，而在C里可以使用冒泡排序等方法）</li></ul><p>为什么是这样的一个前提呢？我们首先应该知道<mark>二分查找的原理<mark>：</mark></mark></p><h2 id="三、二分查找的原理"><a href="#三、二分查找的原理" class="headerlink" title="三、二分查找的原理"></a>三、二分查找的原理</h2><blockquote><p>在一个已经从小到大排好的数组里，先把目标与数组中间值比较<br>* 若目标&gt;中间值，则接着找后半部分，前半部分舍弃。<br>* 若目标&lt;中间值，则接着找前半部分，后半部分舍弃。</p></blockquote><p>那有初学的朋友会问了：<em>数组元素数是偶数的话怎么取中间值？</em></p><p>其实不必纠结这个问题，因为每次都丢掉数组的一半的话，这个问题是一定会出现的。</p><p>虽说叫二分查找，但并不是说我们必须严格的取一半，只是取一半时舍弃掉的不合要求的元素最多，比较节约时间而已。<br>而由于我们使用<strong>int</strong>类型，每次取的就是最中间两个数中靠左的那个，这样一来无非是在搜索的范围里多加一个数而已，只要我们继续进行二分查找并找好边界值，就永远不会有元素被落下。</p><h2 id="四、二分查找的使用"><a href="#四、二分查找的使用" class="headerlink" title="四、二分查找的使用"></a>四、二分查找的使用</h2><p>这里只写我最常用的一种方式：<mark>[left,right]式<mark><br>使用int函数进行运算：</mark></mark></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int binarysearch(int arr[],int size,int target)</span><br><span class="line">&#123;</span><br><span class="line">    //size 可使用int size=sizeof(arr)/sizeof(arr[0])计算</span><br><span class="line"></span><br><span class="line">    int l=0,r=size-1;   //l=left,r=right,m=middle</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        int m=l+(r-l)/2;    //防止直接相加导致溢出</span><br><span class="line">        if(arr[m]&gt;target)&#123;</span><br><span class="line">            r=m-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(arr[m]&lt;target)&#123;</span><br><span class="line">            l=m+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return m;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、二分查找的性能"><a href="#五、二分查找的性能" class="headerlink" title="五、二分查找的性能"></a>五、二分查找的性能</h2><ul><li>时间复杂度：O(1)~O(log<sub>2</sub>n)</li><li>空间复杂度：O(1)~O(log<sub>2</sub>n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公因数和最小公倍数（欧几里得算法）</title>
      <link href="/2022/11/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
      <url>/2022/11/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>我们在学习时经常性遇见求最大公因数和最小公倍数的问题，而使用枚举的话非常容易超时，那么我们应该怎样更快更好地解决它们呢?</p><span id="more"></span><h2 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>又称<em>辗转相除法</em>，使用int类型的函数实现，两个参数的传入条件要求<em><strong>a大于b</strong></em>。<br><strong>百度百科</strong>：欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。<br>总之就是不断把<em>除数当被除数，余数当除数</em><br>假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：<br>1997 ÷ 615 = 3 (余 152)<br>615 ÷ 152 = 4(余7)<br>152 ÷ 7 = 21(余5)<br>7 ÷ 5 = 1 (余2)<br>5 ÷ 2 = 2 (余1)<br>2 ÷ 1 = 2 (余0)<br>至此，最大公约数为1<br>以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    if(a&lt;b)&#123;  //使大的作被除数</span><br><span class="line">        t=a;a=b;b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b==0)  //判断是否存在0的情况</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;%d&quot;,gcd(a,b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>相信你已经学会求最大公因数，那么最小公倍数呢？<br><strong>当然也是非常简单滴！</strong><br><em><strong>最小公倍数=（ab）/最大公因数</strong></em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    if(a&lt;b)&#123;  //使大的作被除数</span><br><span class="line">        t=a;a=b;b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b==0)  //判断是否存在0的情况</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;%d&quot;,(a*b)/gcd(a,b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 求数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>myself</title>
      <link href="/myself/index.html"/>
      <url>/myself/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/messageboard/index.html"/>
      <url>/messageboard/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
