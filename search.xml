<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>进制转换</title>
      <link href="/2022/12/04/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2022/12/04/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="十进制转d进制-d-lt-10"><a href="#十进制转d进制-d-lt-10" class="headerlink" title="十进制转d进制(d&lt;10)"></a>十进制转d进制(d&lt;10)</h2><p>原理很简单，按照计算方法算出每一位后存入数组，倒序输出即可~</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,i=0,x,j,d;</span><br><span class="line">  int arr[1000];</span><br><span class="line">  scanf(&quot;%d%d&quot;,&amp;n,&amp;d);</span><br><span class="line">  if(n==0)</span><br><span class="line">    printf(&quot;0&quot;);</span><br><span class="line">  else&#123;</span><br><span class="line">  while(n&gt;0)&#123;        //想不起来的话把d设成2自己代入一遍</span><br><span class="line">    x=n%d;</span><br><span class="line">    n/=d;</span><br><span class="line">    arr[i]=x;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  for(j=i-1;j&gt;=0;j--)&#123;    //逆序输出</span><br><span class="line">    printf(&quot;%d&quot;,arr[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="d进制转十进制（d-lt-10"><a href="#d进制转十进制（d-lt-10" class="headerlink" title="d进制转十进制（d&lt;10)"></a>d进制转十进制（d&lt;10)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,x=1,num=0,d;</span><br><span class="line">  scanf(&quot;%d%d&quot;,&amp;n,&amp;d);</span><br><span class="line">  while(n&gt;0)&#123;</span><br><span class="line">    num+=(n%10)*x;    //拨出最后一位乘以位权</span><br><span class="line">    n/=10;    //舍弃最后一位</span><br><span class="line">    x*=d;    //位权增加</span><br><span class="line">  &#125;</span><br><span class="line">  printf(&quot;%d&quot;,num);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="十进制转十六进制"><a href="#十进制转十六进制" class="headerlink" title="十进制转十六进制"></a>十进制转十六进制</h2><p>与前面的“十进制转d进制”差不多，只是用<em>字符数组</em>代替了<em>整型数组</em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  int n,i=0,j;</span><br><span class="line">  char arr[1000],brr[20]=&#123;&quot;0123456789ABCDEF&quot;&#125;;</span><br><span class="line">  scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">  if(n==0)</span><br><span class="line">    printf(&quot;0&quot;);</span><br><span class="line">  else&#123;</span><br><span class="line">  while(n&gt;0)&#123;</span><br><span class="line">    arr[i]=brr[n%16];</span><br><span class="line">    n/=16;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  for(j=i-1;j&gt;=0;j--)&#123;</span><br><span class="line">    printf(&quot;%c&quot;,arr[j]);</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>在查找资料的时候发现C艹自带进制转换的函数，顺便记录一下~</p><blockquote><p>oct 是八进制形式<br> dec 是十进制形式<br> hex 是十六进制形式（setiosflags(ios::uppercase)可转换为大写输出）<br>C语言没有专门的二进制转换，故只能规定位数输出二进制</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;bitset&lt;8&gt;(n)&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;oct&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;dec&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;setiosflags(ios::uppercase)&lt;&lt;hex&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归与递推</title>
      <link href="/2022/12/03/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/"/>
      <url>/2022/12/03/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<p>递归与递推是编程问题中重要的思想，如何更好的理解？看完这篇文章你可能会有收获。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h2><blockquote><p>递归，就是在运行的过程中不断调用自己本身。可以分为“递”和“归”两个过程，“递”得到每一个小步的结果，再通过“归”将每次运算的结果结合起来。最后得到答案。</p></blockquote><h2 id="递归优缺点"><a href="#递归优缺点" class="headerlink" title="递归优缺点"></a>递归优缺点</h2><ul><li>优点：代码简解易懂，思维方式符合我们思考的逻辑。</li><li>缺点：运行效率低，需要调用很多栈来储存返回点和局部量等，容易造成栈溢出。</li></ul><h1 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h1><h2 id="递推定义"><a href="#递推定义" class="headerlink" title="递推定义"></a>递推定义</h2><blockquote><p>递推，就是从问题的初始条件出发，通过观察得出某种关系式，通过这个关系式推出各项结果。</p></blockquote><h2 id="递推优缺点"><a href="#递推优缺点" class="headerlink" title="递推优缺点"></a>递推优缺点</h2><ul><li>优点：很好的发挥了计算机重复计算的优点，不会像递推一样占用过多的内存空间。</li><li>缺点：想象不到递推的关系式，从源头上直接gg（doge 。</li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="裴波那契数列"><a href="#裴波那契数列" class="headerlink" title="裴波那契数列"></a>裴波那契数列</h2><blockquote><p>有一对小兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。按此规律，假设没有兔子死亡，第一个月有一对刚出生的小兔子，问第n个月有多少对兔子？</p></blockquote><p>在草稿纸上进行简单的演算，我们会发现:第一个月1对，第二个月1对，第三个月2对，第四个月3对，第五个月5对，第六个月8对，第七个月13对……<strong>从第三项开始，每个月的数量都是前两个月的和</strong></p><p>不难得出，<strong>当n&gt;=3时，本月兔子数量=上个月数量+上上个月数量</strong>。</p><p>递归、递推代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line"></span><br><span class="line">int digui(int n)    //递归</span><br><span class="line">&#123;</span><br><span class="line">    if(n==1||n==2)</span><br><span class="line">        return 1;</span><br><span class="line">    else</span><br><span class="line">        return (digui(n-1)+digui(n-2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ditui(int n)    //递推</span><br><span class="line">&#123;</span><br><span class="line">    int x=1,y=1,z;</span><br><span class="line">    if(n==1||n==2)</span><br><span class="line">        z=1;</span><br><span class="line">    else &#123;</span><br><span class="line">        for(int i=0;i&lt;n-2;i++)&#123;</span><br><span class="line">        z=x+y;</span><br><span class="line">        x=y;</span><br><span class="line">        y=z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    printf(&quot;%d\n&quot;,digui(n));</span><br><span class="line">    printf(&quot;%d\n&quot;,ditui(n));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高中往事回忆</title>
      <link href="/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/"/>
      <url>/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p><img src="/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/0000.jpg" alt="和本组的帅哥美女"></p>]]></content>
      
      
      <categories>
          
          <category> 回忆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈各种排序</title>
      <link href="/2022/11/30/%E6%B5%85%E8%B0%88%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/11/30/%E6%B5%85%E8%B0%88%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序是我们在学习编程的过程中经常用的问题，这篇博客会总结一些我比较常用的一些算法，以供复习和回忆。</p><p>比较常见的排序大致分为两种，<strong>比较型排序</strong>和<strong>非比较型排序</strong></p><ul><li>比较型排序将元素之间两两进行比较，<em>比较耗时间</em>。</li><li>非比较型排序将元素进行记录，<em>比较耗空间</em>。</li></ul><p><em><strong>我们通常认为时间比空间重要，故经常使用牺牲空间的方式来减少运行时间</strong></em></p><h2 id="比较型排序"><a href="#比较型排序" class="headerlink" title="比较型排序"></a>比较型排序</h2><h3 id="一、插入排序"><a href="#一、插入排序" class="headerlink" title="一、插入排序"></a>一、插入排序</h3><p>一个无序数列，从左到右每次取一个数向左依次比较，直至左边有一个数比它小，则插入。</p><blockquote><p>时间复杂度：O(N)~O(N<sup>2)<br>空间复杂度：O(1)</sup></p></blockquote><p>代码部分：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void InsertSort(int arr[],int n)</span><br><span class="line">&#123;</span><br><span class="line">for(int i=0;i&lt;n-1;++i)&#123;  //第一个已经排好序，没必要再参与计算</span><br><span class="line">        int end=i;    //记录有序序列当前最后元素的下标</span><br><span class="line">        int temp=arr[end+1];    //待插入的元素</span><br><span class="line">        while(end&gt;=0)&#123;</span><br><span class="line">            if(arr[end]&gt;temp)&#123;    </span><br><span class="line">                arr[end+1]=arr[end];    //比插入的数大就向后移</span><br><span class="line">                end--;</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">                break;    //比插入的数小，跳出循环</span><br><span class="line">        &#125;</span><br><span class="line">        arr[end+1]=temp;    //放入temp</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[20],i,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    InsertSort(arr,n);</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><p>也是我比较喜欢用的一种排序，每次从左到右相邻的元素两两比较，第一个与第二个比较，让大的那个与第三个比较。这样可以使最大的数排在最右边。</p><blockquote><p>时间复杂度：O(N)~O(N<sup>2)<br>空间复杂度：O(1)</sup></p></blockquote><p>代码部分：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void BubbleSort(int arr[],int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i,j,temp=0;</span><br><span class="line">    for(i=0;i&lt;n-1;i++)&#123;</span><br><span class="line">        for(j=i+1;j&lt;n;j++)&#123;</span><br><span class="line">            if(arr[i]&gt;arr[j])&#123;</span><br><span class="line">                temp=arr[i];</span><br><span class="line">                arr[i]=arr[j];</span><br><span class="line">                arr[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[20],i,n;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    BubbleSort(arr,n);</span><br><span class="line">    for(i=0;i&lt;n;i++)&#123;</span><br><span class="line">        printf(&quot;%d &quot;,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非比较型排序"><a href="#非比较型排序" class="headerlink" title="非比较型排序"></a>非比较型排序</h2><h3 id="计数排序（Count-sort）"><a href="#计数排序（Count-sort）" class="headerlink" title="计数排序（Count sort）"></a>计数排序（Count sort）</h3><p>计数排序也就是我们刚接触数组时使用的排序方法，快于任何一种比较型排序算法，但条件较为苛刻：<strong>数据范围较小，否则非常浪费空间</strong></p><blockquote><p><strong>k为数组长度</strong><br>时间复杂度就是O(n+k)<br>空间复杂度为O(k)</p></blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[1000],brr[1000]=&#123;0&#125;;</span><br><span class="line">    int n,i,j;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;arr[0]);</span><br><span class="line">    brr[arr[0]]++;</span><br><span class="line">    int max=arr[0];</span><br><span class="line">    for(i=1;i&lt;n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d&quot;,&amp;arr[i]);</span><br><span class="line">        brr[arr[i]]++;</span><br><span class="line">        if(arr[i]&gt;max)</span><br><span class="line">            max=arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=0;i&lt;max+1;i++)&#123;</span><br><span class="line">        for(j=0;j&lt;brr[i];j++)&#123;</span><br><span class="line">            printf(&quot;%d &quot;,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈二分查找</title>
      <link href="/2022/11/29/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/11/29/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>相信我们都在编程过程中遇见查找问题，而查找的方式有许多种，我们最常见的、也是使用次数最多的便是<em><strong>二分查找</strong></em>了，原理简单且不容易超时。<br>二分查找的思想很容易理解，但大多数人都是通过记模板来使用，这篇博客将二分法做一个大概的总结，以供记忆和复习。</p><h2 id="一、分享小故事"><a href="#一、分享小故事" class="headerlink" title="一、分享小故事"></a>一、分享小故事</h2><p>这里引用了CSDN中<a href="https://blog.csdn.net/qq_45978890/article/details/116094046?spm=1001.2014.3001.5502">Charon_cc</a>的一个很生动形象的例子：</p><hr><blockquote><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1 本书。</p></blockquote><hr><p>多读两遍我们就会发现<mark>二分查找法的前提<mark>：</mark></mark></p><h2 id="二、二分查找的前提"><a href="#二、二分查找的前提" class="headerlink" title="二、二分查找的前提"></a>二、二分查找的前提</h2><ul><li><strong>查找的目标只能有一个</strong></li><li><strong>查找的范围内元素是有序的</strong>（排序在C++里可以直接使用sort，而在C里可以使用冒泡排序等方法）</li></ul><p>为什么是这样的一个前提呢？我们首先应该知道<mark>二分查找的原理<mark>：</mark></mark></p><h2 id="三、二分查找的原理"><a href="#三、二分查找的原理" class="headerlink" title="三、二分查找的原理"></a>三、二分查找的原理</h2><blockquote><p>在一个已经从小到大排好的数组里，先把目标与数组中间值比较<br>* 若目标&gt;中间值，则接着找后半部分，前半部分舍弃。<br>* 若目标&lt;中间值，则接着找前半部分，后半部分舍弃。</p></blockquote><p>那有初学的朋友会问了：<em>数组元素数是偶数的话怎么取中间值？</em></p><p>其实不必纠结这个问题，因为每次都丢掉数组的一半的话，这个问题是一定会出现的。</p><p>虽说叫二分查找，但并不是说我们必须严格的取一半，只是取一半时舍弃掉的不合要求的元素最多，比较节约时间而已。<br>而由于我们使用<strong>int</strong>类型，每次取的就是最中间两个数中靠左的那个，这样一来无非是在搜索的范围里多加一个数而已，只要我们继续进行二分查找并找好边界值，就永远不会有元素被落下。</p><h2 id="四、二分查找的使用"><a href="#四、二分查找的使用" class="headerlink" title="四、二分查找的使用"></a>四、二分查找的使用</h2><p>这里只写我最常用的一种方式：<mark>[left,right]式<mark><br>使用int函数进行运算：</mark></mark></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int binarysearch(int arr[],int size,int target)</span><br><span class="line">&#123;</span><br><span class="line">    //size 可使用int size=sizeof(arr)/sizeof(arr[0])计算</span><br><span class="line"></span><br><span class="line">    int l=0,r=size-1;   //l=left,r=right,m=middle</span><br><span class="line">    while(l&lt;=r)&#123;</span><br><span class="line">        int m=l+(r-l)/2;    //防止直接相加导致溢出</span><br><span class="line">        if(arr[m]&gt;target)&#123;</span><br><span class="line">            r=m-1;</span><br><span class="line">        &#125;</span><br><span class="line">        else if(arr[m]&lt;target)&#123;</span><br><span class="line">            l=m+1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">            return m;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、二分查找的性能"><a href="#五、二分查找的性能" class="headerlink" title="五、二分查找的性能"></a>五、二分查找的性能</h2><ul><li>时间复杂度：O(1)~O(log<sub>2</sub>n)</li><li>空间复杂度：O(1)~O(log<sub>2</sub>n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公因数和最小公倍数（欧几里得算法）</title>
      <link href="/2022/11/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
      <url>/2022/11/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>我们在学习时经常性遇见求最大公因数和最小公倍数的问题，而使用枚举的话非常容易超时，那么我们应该怎样更快更好地解决它们呢?</p><span id="more"></span><h2 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>又称<em>辗转相除法</em>，使用int类型的函数实现，两个参数的传入条件要求<em><strong>a大于b</strong></em>。<br><strong>百度百科</strong>：欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。<br>总之就是不断把<em>除数当被除数，余数当除数</em><br>假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：<br>1997 ÷ 615 = 3 (余 152)<br>615 ÷ 152 = 4(余7)<br>152 ÷ 7 = 21(余5)<br>7 ÷ 5 = 1 (余2)<br>5 ÷ 2 = 2 (余1)<br>2 ÷ 1 = 2 (余0)<br>至此，最大公约数为1<br>以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    if(a&lt;b)&#123;  //使大的作被除数</span><br><span class="line">        t=a;a=b;b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b==0)  //判断是否存在0的情况</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;%d&quot;,gcd(a,b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>相信你已经学会求最大公因数，那么最小公倍数呢？<br><strong>当然也是非常简单滴！</strong><br><em><strong>最小公倍数=（ab）/最大公因数</strong></em></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int gcd(int a,int b)</span><br><span class="line">&#123;</span><br><span class="line">    int t;</span><br><span class="line">    if(a&lt;b)&#123;  //使大的作被除数</span><br><span class="line">        t=a;a=b;b=t;</span><br><span class="line">    &#125;</span><br><span class="line">    if(b==0)  //判断是否存在0的情况</span><br><span class="line">        return a;</span><br><span class="line">    else</span><br><span class="line">        return gcd(b,a%b);</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a,b;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</span><br><span class="line">    printf(&quot;%d&quot;,(a*b)/gcd(a,b));</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 求数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/messageboard/index.html"/>
      <url>/messageboard/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>myself</title>
      <link href="/myself/index.html"/>
      <url>/myself/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
