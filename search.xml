<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python知识点</title>
      <link href="/2023/03/09/python%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2023/03/09/python%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>这里记录了一些初学Python代码时遇见的知识点。</p><h1 id="string函数"><a href="#string函数" class="headerlink" title="string函数"></a>string函数</h1><h2 id="string模块中记录了一些常用的属性"><a href="#string模块中记录了一些常用的属性" class="headerlink" title="string模块中记录了一些常用的属性"></a>string模块中记录了一些常用的属性</h2><h3 id="数字，字母等"><a href="#数字，字母等" class="headerlink" title="数字，字母等"></a>数字，字母等</h3><p><strong>ascii</strong></p><pre class="line-numbers language-none"><code class="language-none">import stringprint(string.ascii_letters) &#x2F;&#x2F;&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;print(stirng.ascii_lowercase) &#x2F;&#x2F;&#39;abcdefghijklmnopqrstuvwxyz&#39;print(string.ascii_uppercase) &#x2F;&#x2F;&#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;print(string.digits) &#x2F;&#x2F;&#39;0123456789&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="大小写转化"><a href="#大小写转化" class="headerlink" title="大小写转化"></a>大小写转化</h3><p>**upper()**可以将字符串变为大写，可单独使用，可也以放进print<br>**lower()**可以将字符串变为小写，可单独使用，可也以放进print</p><pre class="line-numbers language-none"><code class="language-none">print(s.upper()) &#x2F;&#x2F;注意只是生成新的字符串，并没有更改<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="大小写反转"><a href="#大小写反转" class="headerlink" title="大小写反转"></a>大小写反转</h3><p><strong>swapcase()</strong></p><pre class="line-numbers language-none"><code class="language-none">print(s.swapcase())<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="首字母大写"><a href="#首字母大写" class="headerlink" title="首字母大写"></a>首字母大写</h3><p>**title()**所有给的单词首字母大写，其余小写<br>**capitalize()**只大写整个字符串的第一个字母,其余小写</p><pre class="line-numbers language-none"><code class="language-none">import strings &#x3D; &quot;abcd,qwerTYU&quot;t &#x3D; &quot;abcd qwerTYU&quot;print(s.title())    &#x2F;&#x2F;Abcd,Qwertyuprint(s.capitalize())   &#x2F;&#x2F;Abcd,qwertyuprint(t.title())    &#x2F;&#x2F;Abcd Qwertyuprint(t.capitalize())   &#x2F;&#x2F;Abcd qwertyu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="is判断函数"><a href="#is判断函数" class="headerlink" title="is判断函数"></a>is判断函数</h2><p>**isdecimal()**判断字符串是否全部为数字<br>**isalpha()**判断字符串是否全部为字母<br>**isalnum()**判断给定的字符串是否只含有数字与字母<br>**isupper()**判断给定的字符串是否全为大写<br>**islower()**判断给定的字符串是否全为小写<br>**istitle()**判断给定的字符串是否符合title()<br><strong>isspace()</strong>:判断给定的字符串是否为空白符（空格、换行、制表符）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; \n为换行 是空白符 为Trueprint(&quot;\n&quot;.isspace())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>isprintable()</strong>:判断给定的字符串是否为可打印字符（只有空格可以，换行、制表符都不可以）</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; \t为制表符 不可打印 为Falseprint(&quot;\t&quot;.isprintable())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>isidentifier()</strong>:判断给定的字符串是否符合命名规则（只能是字母或下划线开头,且不能包含除数字、字母和下划线以外的任意字符</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; qe123 符合命名规则 为Trueprint(&quot;qe125&quot;.isidentifier())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="字符串填充"><a href="#字符串填充" class="headerlink" title="字符串填充"></a>字符串填充</h2>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客笔记2</title>
      <link href="/2023/02/07/%E7%89%9B%E5%AE%A2%E7%AC%94%E8%AE%B02/"/>
      <url>/2023/02/07/%E7%89%9B%E5%AE%A2%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客笔记1</title>
      <link href="/2023/02/01/%E7%89%9B%E5%AE%A2%E7%AC%94%E8%AE%B01/"/>
      <url>/2023/02/01/%E7%89%9B%E5%AE%A2%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1 id="基础题1-World-Final-World-Cup-I-（模拟）"><a href="#基础题1-World-Final-World-Cup-I-（模拟）" class="headerlink" title="基础题1 World Final? World Cup! (I)（模拟）"></a>基础题1 World Final? World Cup! (I)（<em>模拟</em>）</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>众所周知，2022年是四年一度的世界杯年，那么当然要整点足球题。本题需要你模拟一次点球大战。</p><p>假设对战双方为A和B，则点球大战中双方会按照ABABABABAB方式来罚点球，即两队交替罚点球、各罚五次、A队先罚。点球有罚进和罚不进两种结果，罚中的一方加一分。</p><p>其判断胜负的规则为得分多者获胜，而若在罚完某一球后（无论是哪队罚的），当前双方比分已经使得无论之后的罚球结果如何都不会影响比赛的结果，则此时比赛结束。特别地，若直到10球踢完都没有分出胜负则再继续加踢更多的点球。</p><p>现在，给出接下来双方10个点球的结果，你需要判断点球大战会在踢完几球时结束，或指出10球内没有分出胜负</p><h3 id="输入描述"><a href="#输入描述" class="headerlink" title="输入描述:"></a>输入描述:</h3><p>输入第一行包含一个整数T (1≤T≤1024)，表示样例组数。</p><p>每组测试用例包括一个长度为10的字符串S，第i个字符表示第i个点球的结果，0表示罚不进，1表示罚进</p><h3 id="输出描述："><a href="#输出描述：" class="headerlink" title="输出描述："></a>输出描述：</h3><p>对每组测试用例，输出一个整数，表示点球大战会在第几回合结束，若10轮之内没有分出胜负，输出-1。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从1开始将每种情况列举出来，对于每种情况进行判断：剩下的10-i场比赛里，设A最高A1分，最低A2分，B最高B1分，最低B2分，判断（A1-B2)*(B1-A2)是否&lt;0 <strong>（前者代表A最好的情况能不能赢B，后者代表B最好的情况能不能赢A）</strong></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main()&#123;int T;char s[11];scanf(&quot;%d&quot;,&amp;T);while(T--)&#123;        scanf(&quot;%s&quot;,s+1);   &#x2F;&#x2F;        int a&#x3D;0,b&#x3D;0,flag&#x3D;1;        for(int i&#x3D;1;i&lt;&#x3D;10;i++)&#123;            if(s[i]&#x3D;&#x3D;&#39;1&#39;)&#123;                if(i%2)                    a++;                else                    b++;            &#125;        int a1&#x3D;(10-i)&#x2F;2,b1&#x3D;(11-i)&#x2F;2;   &#x2F;&#x2F;b1的计算方式使b的情况不会被漏掉        if((a+a1-b)*(b+b1-a)&lt;0)&#123;            printf(&quot;%d\n&quot;,i);            flag&#x3D;0;            break;        &#125;        &#125;    if(flag)        printf(&quot;-1\n&quot;);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基础题2-本题主要考察了运气（数学）"><a href="#基础题2-本题主要考察了运气（数学）" class="headerlink" title="基础题2 本题主要考察了运气（数学）"></a>基础题2 本题主要考察了运气（<em>数学</em>）</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>《P–j— S-k–》是一款S-g-发行的音乐游戏，游戏中除了主打的-家虚拟歌姬角色外，还有大量人设饱满的原创角色。而知名算法竞赛选手J—-ly就是该游戏的玩家。现在，你想猜出J—-ly在该游戏中最喜欢的原创角色是谁。</p><p>该游戏中共有20名原创角色，分别属于5个团体，每个团体恰好4个人。为了猜出J—-ly最喜欢的角色，你可以向他提以下两类问题（J—-ly会如实回答）：</p><p>现在，你想知道，在选择最优的提问策略使提问数尽可能少的情况下，你的期望提问次数是多少次？本题要求输出该期望次数。</p><p>特别地，好心的出题人为了让这题有100%的通过率，把这题出成了选择题的形式，选项含义见输出描述部分。</p><p>下面给出一种可能的提问示例：</p><p>问题一：ta属于第3个团体吗？回答：不属于。</p><p>问题二：ta属于第1个团体吗？回答：不属于。</p><p>问题三：ta是第2个团体第2个人吗？回答：不是。</p><p>问题四：ta是第4个团体第3个人吗？回答：是。</p><p>此时，你通过四个问题，能100%确定J—-ly最喜欢的角色是第4个团体的第3个角色，提问次数为4。</p><h3 id="输入描述-1"><a href="#输入描述-1" class="headerlink" title="输入描述"></a>输入描述</h3><p>本题没有输入，直接输出你的答案。</p><h3 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述"></a>输出描述</h3><p>如题面所述，本题很好心，是个选择题，共有100个选项（最多99发罚时就可以保证通过此题辣），选项编号为1至100，第i个选项为3.45+0.05*i，如第一个选项为3.50，第十个选项为3.95。你需要选出与答案最接近的选项的编号（一个1至100的整数）。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>高中的期望问题</p><p>猜团时：共5个团，第①次猜中概率是0.2，第②次概率是0.2，第③次概率是0.2，第④次概率是0.4（第四次猜已经可以判断出第五次的结果了）。</p><p>猜人时：共四个人，第①次猜中概率是0.25，第②次概率是0.25，第③次概率是0.5。</p><p>最后将猜团和猜人的期望计算并相加：1 * 0.2 + 2 * 0.2 + 3 * 0.2 + 4 * 0.4 + 1 * 0.25 + 2 * 0.25 + 3 * 0.5=5.05，即32。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int main()&#123;    printf(&quot;32&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基础题3-现在是，学术时间-I-（诈骗，思维，贪心）"><a href="#基础题3-现在是，学术时间-I-（诈骗，思维，贪心）" class="headerlink" title="基础题3 现在是，学术时间 (I)（诈骗，思维，贪心）"></a>基础题3 现在是，学术时间 (I)（<em>诈骗，思维，贪心</em>）</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>北京IT大学（BIT）计算机学院为了在下一轮学科评估中让计算机学科获得A+的评定结果，进行了如引进强大的老师、加强课程之类、提高授课质量等多方面的努力。而为了提高学科评估中，学术成果一项的得分，计算机学院的院长打算通过重新分配论文的方式使得学院里所有教授的H指数值之和尽可能大。</p><p>具体来说，H指数用于粗略的评估一位教授的学术水平。一位教授可以发表多篇论文，每篇论文有一个引用量。定义一位教授的H指数为使得”该教授发表的所有论文中，有至少H篇论文的引用量大于等于H”这一命题成立的最大的H。</p><p>现在，院长发现学院里的每位老师当前的发表文章数都为0，且恰好每人都有一篇写好的论文未发表，由于院长很懂学术界，他也可以准确的预知到每篇文章发表后的引用量。院长决定以最优的方式重新分配这些论文，他可以任意指定一篇论文由哪位教授发表。规定每篇论文只能被一位教授发表，一位教授可以发表多篇论文。</p><p>即所有教授的H指数之和最大。院长希望最大化$$\sum_{i=1}^{n}h_i$$,即所有教授的H指数和最大，请你帮院长计算出这一最大的值为多少。</p><h3 id="输入描述-2"><a href="#输入描述-2" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入第一行为一个正整数T(1≤T≤10^5)，表示样例组数。</p><p>每组样例包括两行。</p><p>第一行是一个正整数n(1≤n≤10^5)，表示北京IT大学计算机学院的教授数量；第二行包括nnn个非负整数，第iii个数字ai(0≤ai≤109)表示第i位教授写好但未发表的文章在发表后会获得的引用量。</p><p>保证每组数据所有用例的n之和Σn≤5×10^5.</p><h3 id="输出描述-1"><a href="#输出描述-1" class="headerlink" title="输出描述"></a>输出描述</h3><p>对于每组样例，输出一个整数，表示$$\sum_{i=1}^{n}h_i$$的最大值</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>什么都不做的话结果最佳，不进行重新分配。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main()&#123;int t,a,arr[100005];scanf(&quot;%d&quot;,&amp;t);while(t--)&#123;        scanf(&quot;%d&quot;,&amp;a);        int ans&#x3D;0;        for(int i&#x3D;0;i&lt;a;i++)&#123;            scanf(&quot;%d&quot;,&amp;arr[i]);            if(arr[i]&gt;0) ans++;        &#125;        printf(&quot;%d\n&quot;,ans);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基础题4：本题主要考察了DFS（诈骗，思维，贪心）"><a href="#基础题4：本题主要考察了DFS（诈骗，思维，贪心）" class="headerlink" title="基础题4：本题主要考察了DFS（诈骗，思维，贪心）"></a>基础题4：本题主要考察了DFS（<em>诈骗，思维，贪心</em>）</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>PTA的拼图由n∗n个大小为1∗1的拼图块组成，每个拼图块都是在正方形的1∗1拼图块基础上生成的，生成方法为：对于每一条边，可以选择不变、向里削出一个半圆形的缺口、向外补上一个半圆形的凸出三种操作之一。因此，一个拼图块可以由一个长度为444的字符串描述，四个字符分别表示上、右、下、左四条边进行的操作，上述三种操作依次记为0,1,2。</p><p>  例如，下图的左图为一个2∗2的拼图。而右图为左图中左上角的一块1∗1拼图的字符串描述，由于其上、右、下、左进行的操作分别为不变、凸出、缺口、不变，因此这块拼图对应的字符串为0210。</p><p>每块拼图还有一个制作成本p，正比与面积，而拼图中削去的缺口和补上的凸出面积又相同，因此对于一块削去了x个半圆、补上了y个半圆的1*1拼图，其制作成本为p=10-1+1=10.</p><p>现在，PTA会从所有拼图中随机隐藏一块，并打乱剩下的$n^{2}$​-1块拼图，告诉了你它们的形状对应的字符串表示（由于拼图上绘制了可供辨识的图案，因此给出的拼图形状都是各拼图块正面朝上、未经旋转的正确形状）。</p><p>PTA需要你完成这一拼图游戏，还原拼图原来的样子。你需要回答隐藏起来的那块拼图的制作成本来证明你成功完成了拼图。</p><h3 id="输入描述-3"><a href="#输入描述-3" class="headerlink" title="输入描述"></a>输入描述</h3><p>输入第一行是一个整数T(1≤T≤100)，表示测试用例组数。</p><p>对于每组测试用例：</p><p>第一行为一个正整数n(2≤n≤20)，表示拼图的大小。</p><p>接下来$n^{2}$-1行，每行一个长度为4的字符串，表示一块拼图正面朝上、未经旋转的形状。保证字符串中只含0,1,2三种字符。</p><p>输入数据保证$n^{2}$−1块拼图是从一个合法的n∗n拼图中按如题面所述的过程获得的。</p><h3 id="输出描述-2"><a href="#输出描述-2" class="headerlink" title="输出描述"></a>输出描述</h3><p>对每组样例输出一个整数，表示你在拼出拼图后所计算出的缺失拼图块的制作成本。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main()&#123;int t,a,ans&#x3D;10;string s;scanf(&quot;%d&quot;,&amp;t);while(t--)&#123;        scanf(&quot;%d&quot;,&amp;a);        ans&#x3D;10;        for(int i&#x3D;0;i&lt;a*a-1;i++)&#123;            cin&gt;&gt;s;            for(int j&#x3D;0;j&lt;4;j++)&#123;            if(s[j]&#x3D;&#x3D;&#39;0&#39;) continue;            else if(s[j]&#x3D;&#x3D;&#39;1&#39;) ans++;            else if(s[j]&#x3D;&#x3D;&#39;2&#39;) ans--;            &#125;        &#125;        printf(&quot;%d\n&quot;,ans);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对结构体的理解</title>
      <link href="/2022/12/29/%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2022/12/29/%E5%AF%B9%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>在C语言中，数据类型被分为基础数据类型和复合数据类型。</p><p>对于基础数据类型我们都有了解，如int，char等，但复合数据类型又是什么情况呢？</p><p><strong>复合数据类型分为结构、联合、和枚举。这里我们只谈结构（structure）</strong></p><h1 id="结构体的声明和定义"><a href="#结构体的声明和定义" class="headerlink" title="结构体的声明和定义"></a>结构体的声明和定义</h1><p>struct  【结构体名称】{<br>    成员1；<br>    成员2；<br>    ……<br>} 结构体变量名；*//一定要加分号，这是一个声明的结束。*</p><p><strong>例如：声明一种水果的信息</strong></p><pre class="line-numbers language-none"><code class="language-none">struct fruits&#123;    char name[20];    double price;    double weight;&#125;a,b,c;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样我们就成功声明了变量a，b，c；</p><p><mark>注意，我们只是声明了a，b，c，并不能给它们赋值，因为对于计算机来说struct{}和int是一个意思，都只是一种类型声明，正如同手搓出一个框架一样。当然，此时struct也是不占用内存的。<mark></mark></mark></p><ul><li>我们也可以不加fruits，只声明a，b，c。但这样的结果是我们只能定义a，b，c，不能再定义别的变量。</li></ul><h1 id="结构体的使用"><a href="#结构体的使用" class="headerlink" title="结构体的使用"></a>结构体的使用</h1><p>说完了声明，我们接下来学学如何使用结构体。</p><p>与常见的声明一样，我们可以在定义结构体时就初始化，也可以先定义在使用的时候再初始化。</p><pre class="line-numbers language-none"><code class="language-none">struct fruits&#123;    char name[20];    double price;    double weight;&#125;a&#x3D;&#123;&quot;apple&quot;,5.8,1.0&#125;;int main()&#123;    struct fruits b&#x3D;&#123;&quot;banana&quot;,6.8,2.0&#125;;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结构体的使用也有两种方式，一种是直接引用，另一种是使用指针：<br><strong>直接引用</strong><br>使用<em><strong>变量名.成员名</strong></em></p><pre class="line-numbers language-none"><code class="language-none">struct fruits&#123;    char name[20];    double price;    double weight;&#125;a&#x3D;&#123;&quot;apple&quot;, 5.8, 1.0&#125;;int main()&#123;    struct fruits b&#x3D;&#123;&quot;banana&quot;, 6.8, 2.0&#125;;    printf(&quot;%s %lf %lf&quot;,a.name,a.price,a.weight);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>使用指针</strong><br>使用【-&gt;】</p><pre class="line-numbers language-none"><code class="language-none">struct fruits&#123;    char name[20];    double price;    double weight;&#125;a&#x3D;&#123;&quot;apple&quot;, 5.8, 1.0&#125;;int main()&#123;    struct fruits b&#x3D;&#123;&quot;banana&quot;, 6.8, 2.0&#125;;    struct fruits *p&#x3D;&amp;b;    printf(&quot;%s %lf %lf&quot;,p-&gt;name,p-&gt;price,p-&gt;weight);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> https://pic1.zhimg.com/80/v2-7691a11831b076f7f1a385a4c7620899_720w.webp?source=1940ef5c </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22级天梯赛题解</title>
      <link href="/2022/12/11/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%A2%98%E8%A7%A3/"/>
      <url>/2022/12/11/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%A2%98%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h2 id="1-1-无所谓，我会出手"><a href="#1-1-无所谓，我会出手" class="headerlink" title="1-1 无所谓，我会出手"></a>1-1 无所谓，我会出手</h2><blockquote><p>请直接输出 ：“It doesn’t matter,I’ll do it.”（输出不含引号）。</p></blockquote><ul><li>直接输出即可。<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    printf(&quot;It doesn&#39;t matter,I&#39;ll do it.&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="1-2-数组总和"><a href="#1-2-数组总和" class="headerlink" title="1-2 数组总和"></a>1-2 数组总和</h2><blockquote><p>给出一个正整数 n 和一段长度为n的数组a1,a2…an ，请输出1×a1+2×a2+3×a3+4×a 4​+…+n×an的结果。</p></blockquote><p><em><strong>输入格式</strong></em><br>第一行为 整数 n（1&lt;=n&lt;=1e3)<br>第二行为n 个整数 ai（1&lt;=ai&lt;=1e9）</p><p><em><strong>输出格式</strong></em><br>输出一行一个正整数，代表题目要求的值。</p><p><strong>样例输入</strong><br>4<br>1 2 3 4<br><strong>样例输出</strong><br>30</p><ul><li>使用for循环，初始化i=1，每次相乘后储存到sum里。注意sum需要long long类型，避免爆int。<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,i;    long long sum&#x3D;0,x;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;1;i&lt;&#x3D;n;i++)&#123;        scanf(&quot;%lld&quot;,&amp;x);        sum+&#x3D;x*i;    &#125;    printf(&quot;%lld&quot;,sum);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="1-3-捡到一个矩形"><a href="#1-3-捡到一个矩形" class="headerlink" title="1-3 捡到一个矩形"></a>1-3 捡到一个矩形</h2><blockquote><p>这天，我捡到了一个二维坐标轴，坐标轴上有一个矩形，现在给出一个点的坐标，问这个坐标是否在矩形中。</p></blockquote><p><em><strong>输入格式</strong></em><br>输入第一行一个整数t，代表测试组数 (1&lt;=t&lt;=10)<br>接下来2×t行，每组测试用例第一行为四个整数，分别为正方形的左下角的坐标x1，y1和矩形的右上角 x2，y2<br>第二行为询问的点的坐标 x，y(−1e9&lt;=x,y,x1,x2,y1,y2&lt;=1e9)</p><p><em><strong>输出格式</strong></em><br>如果在矩形中或者在矩形的边界上，输出 YES；否则输出 NO。</p><p><strong>样例输入</strong><br>2<br>0 0 2 2<br>1 1<br>1 1 2 2<br>0 0<br><strong>样例输出</strong><br>YES<br>NO</p><ul><li>坐标在给出的范围之内即可。<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,i,x1,x2,y1,y2,x,y;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d%d%d%d&quot;,&amp;x1,&amp;y1,&amp;x2,&amp;y2);        scanf(&quot;%d%d&quot;,&amp;x,&amp;y);        if(x&gt;&#x3D;x1&amp;&amp;x&lt;&#x3D;x2&amp;&amp;y&gt;&#x3D;y1&amp;&amp;y&lt;&#x3D;y2)            printf(&quot;YES\n&quot;);        else            printf(&quot;NO\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="1-4-字符转换"><a href="#1-4-字符转换" class="headerlink" title="1-4 字符转换"></a>1-4 字符转换</h2><blockquote><p>现给你一种对字符的操作，使其变成该字符在字母表后的第x个位置，x为该字符在字母表中的位置。例如，对字符a进行操作，会将其变成a后的第一个字母，即b；对字符b进行操作，会将其变成b后的第二个字母，即d….以此类推。需要注意的是，该字母表是一个循环字母表，即字符z后的第一个字符是a，a后又是b，循环往复。现在给你一个字符串s，s 均由小写字母组成，1&lt;=∣s∣&lt;=1e5，请输出对字符串s的每一位字符进行操作后的结果。</p></blockquote><p><em><strong>输入格式</strong></em><br>一行输入一个字符串s，含义如题面所示</p><p><em><strong>输出格式</strong></em><br>输出一行一个字符串，代表对s每一位字符进行操作后的结果。</p><p><strong>样例输入</strong><br>upupup<br><strong>样例输出</strong><br>pfpfpf</p><ul><li>难点是对循环的处理，我的处理方法是通过判断26个字母的中间作为是否循环的标志<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    char arr[100005];    scanf(&quot;%s&quot;,arr);    for(int i&#x3D;0;arr[i]!&#x3D;&#39;\0&#39;;i++)&#123;        if(arr[i]-&#39;a&#39;+1&gt;13)            arr[i]-&#x3D;25-arr[i]+&#39;a&#39;;    &#x2F;&#x2F;等同于26-（arr[i]-&#39;a&#39;+1）        else        arr[i]+&#x3D;arr[i]-&#39;a&#39;+1;    &#125;    for(int i&#x3D;0;arr[i]!&#x3D;&#39;\0&#39;;i++)&#123;        printf(&quot;%c&quot;,arr[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="1-5-捡到了一个成绩"><a href="#1-5-捡到了一个成绩" class="headerlink" title="1-5 捡到了一个成绩"></a>1-5 捡到了一个成绩</h2><blockquote><p>天梯赛过后，所有同学的成绩被打印在一张纸上。现在老师想要统计某班得分的均值，以及得分高于这个均值的同学们的分数之和，请你帮助老师计算出这两个值。</p></blockquote><p><em><strong>输入格式</strong></em><br>第一行输入一个正整数n，代表该班级的人数。(1&lt;=n&lt;=30)<br>第二行输入n个整数，代表第i名同学的得分x。(0&lt;=x&lt;=290)</p><p><em><strong>输出格式</strong></em><br>输出两行，第一行输出一个实数，代表得分的均值。(保留到小数点后三位)<br>第二行输出一个整数，代表得分高于该班级分数均值的同学们的分数之和。</p><p><strong>样例输入</strong><br>6<br>13 105 237 173 273 134<br><strong>样例输出</strong><br>155.833<br>683</p><ul><li>简单题，注意整型要*1.0<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,sum&#x3D;0,sum2&#x3D;0,arr[10000];    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);        sum+&#x3D;arr[i];    &#125;    double aver&#x3D;sum*1.0&#x2F;n;    for(int i&#x3D;0;i&lt;n;i++)&#123;        if(arr[i]*1.0&gt;aver)            sum2+&#x3D;arr[i];    &#125;    printf(&quot;%.3lf\n%d&quot;,aver,sum2);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="1-6-炎爆"><a href="#1-6-炎爆" class="headerlink" title="1-6 炎爆"></a>1-6 炎爆</h2><blockquote><p>cys学姐非常喜欢Arknights这款游戏，而其中伊芙利特是她最引以为傲的干员之一。给你一个n×n的矩形a，矩形中的每一个位置都有一个敌人，其中a[x][y]代表矩形第x行，第y列上的敌人。假设伊芙利特部署在(x,y)的位置上，并且朝向右，那么伊芙利特会对(x,y),(x,y+1),(x,y+2)….(x,n)的所有敌人造成1点伤害。现在给你q次部署，每次部署都给出一个部署位置(x,y)，代表伊芙利特部署在矩形的第x行，第y列，再给出一个字符op，代表伊芙利特的朝向（U代表向上，R代表向右，D代表向下，L代表向左）。你能精确算出每个敌人受到的伤害吗？</p></blockquote><p><em><strong>输入格式</strong></em><br>第一行一个正整数n，代表矩形的大小(1&lt;=n&lt;=100)，初始情况下所有敌人受到的伤害为0。<br>第二行给出一个正整数q，代表伊芙利特的部署次数(1&lt;=q&lt;=50)。<br>接下来q行，每行给定一个数对(x,y)，1&lt;=x,y&lt;=n，代表伊芙利特的部署位置，和一个字符op，op∈{U,R,D,L}，代表伊芙利特的朝向。</p><p><em><strong>输出格式</strong></em><br>输出n行，每行n个整数，分别对应矩阵a中每个敌人受到的伤害。</p><p><strong>样例输入</strong><br>5<br>3<br>2 2 R<br>4 3 U<br>5 5 L<br><strong>样例输出</strong><br>0 0 1 0 0<br>0 1 2 1 1<br>0 0 1 0 0<br>0 0 1 0 0<br>1 1 1 1 1<br><img src="/2022/12/11/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%A2%98%E8%A7%A3/0002.png" alt="题目图片"></p><ul><li>使用for循环控制好变量处理即可，不难但有点麻烦。<br>注意行末空格的处理！<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,x,numx,numy;    char dire;    scanf(&quot;%d&quot;,&amp;n);    int arr[n+1][n+1];    for(int i&#x3D;0;i&lt;n;i++)&#123;        for(int j&#x3D;0;j&lt;n;j++)&#123;            arr[i][j]&#x3D;0;        &#125;    &#125;    scanf(&quot;%d&quot;,&amp;x);    for(int i&#x3D;0;i&lt;x;i++)&#123;        scanf(&quot;%d%d %c&quot;,&amp;numx,&amp;numy,&amp;dire);        if(dire&#x3D;&#x3D;&#39;U&#39;)&#123;            for(int z&#x3D;0,j&#x3D;0;j&lt;numx;j++,z++)&#123;                arr[numx-1-z][numy-1]++;            &#125;        &#125;        else if(dire&#x3D;&#x3D;&#39;R&#39;)&#123;            for(int z&#x3D;0,j&#x3D;0;j&lt;n-numy+1;j++,z++)&#123;                arr[numx-1][numy-1+z]++;            &#125;        &#125;        else if(dire&#x3D;&#x3D;&#39;D&#39;)&#123;            for(int z&#x3D;0,j&#x3D;0;j&lt;n-numx+1;j++,z++)&#123;                arr[numx-1+z][numy-1]++;            &#125;        &#125;        else if(dire&#x3D;&#x3D;&#39;L&#39;)&#123;            for(int z&#x3D;0,j&#x3D;0;j&lt;numy;j++,z++)&#123;                arr[numx-1][numy-1-z]++;            &#125;        &#125;    &#125;    for(int i&#x3D;0;i&lt;n;i++)&#123;        for(int j&#x3D;0;j&lt;n;j++)&#123;            if(j&#x3D;&#x3D;0)                printf(&quot;%d&quot;,arr[i][j]);            else            printf(&quot; %d&quot;,arr[i][j]);            if(j&#x3D;&#x3D;n-1)                printf(&quot;\n&quot;);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="1-7-攻略迷宫"><a href="#1-7-攻略迷宫" class="headerlink" title="1-7 攻略迷宫"></a>1-7 攻略迷宫</h2><blockquote><p>小A准备挑战一个副本，他的角色拥有 x 点生命值，boss 每第 y 秒攻击一次，每次对角色造成1点伤害，当角色生命值为零时游戏结束，不会再受到攻击。现在给你一个时间段，假如小A从这个时间段开始时着手攻略副本，小A想知道他的角色在这段时间内会承受多少次攻击，以及最后一次被攻击的时间。</p></blockquote><p><em><strong>输入格式</strong></em><br>第一行两个整数 x 和 y(1&lt;=x,y&lt;=100) ，由空格隔开。<br>下面两行两个时间，格式为XX:XX:XX ，代表给定的时间段的开始和结束时间。<br>数据保证时间合法，且开始时间和结束时间在同一天</p><p><em><strong>输出格式</strong></em><br>输出共两行：<br>第一行为小A的角色承受boss攻击的次数<br>第二行一个时间，代表小A的角色最后一次遭受攻击的时间，格式为XX:XX:XX</p><p><strong>样例输入</strong><br>5 60<br>18:00:00<br>18:04:30<br><strong>样例输出</strong><br>4<br>18:04:00<br><strong>样例说明</strong><br>如样例，boss 每第 60 秒攻击一次，角色第一次受到攻击时 18：01：00，最后一次是18：04：00 。共承受 4 次攻击。</p><ul><li>时分秒的计算繁琐且十分容易错，我们可以全部转换为秒再进行计算<pre class="line-numbers language-none"><code class="language-none">int miao(int t11,int t22,int t33)    &#x2F;&#x2F;转换为秒&#123;    int miaouu&#x3D;t33+t22*60+t11*3600;    return miaouu;&#125;void biao(int ress)   &#x2F;&#x2F;转换为标准格式&#123;    int h&#x3D;0,m&#x3D;0,s&#x3D;0;    while(ress&gt;&#x3D;3600)&#123;         h++;         ress-&#x3D;3600;    &#125;    while(ress&gt;&#x3D;60)&#123;         m++;         ress-&#x3D;60;    &#125;        s&#x3D;ress;    printf(&quot;%02d:%02d:%02d&quot;,h,m,s);&#125;int main()&#123;    int x,y,t1,t2,t3,tt1,tt2,tt3,time1,time2,num&#x3D;0;    scanf(&quot;%d%d&quot;,&amp;x,&amp;y);    scanf(&quot;%d:%d:%d&quot;,&amp;t1,&amp;t2,&amp;t3);    scanf(&quot;%d:%d:%d&quot;,&amp;tt1,&amp;tt2,&amp;tt3);    time1&#x3D;miao(t1,t2,t3);    time2&#x3D;miao(tt1,tt2,tt3);    int time&#x3D;time2-time1;    while(time&gt;&#x3D;y&amp;&amp;x&gt;0)&#123;        num++;        time-&#x3D;y;        time1+&#x3D;y;        x--;    &#125;    printf(&quot;%d\n&quot;,num);    biao(time1);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="1-8-去掉重复的数据"><a href="#1-8-去掉重复的数据" class="headerlink" title="1-8 去掉重复的数据"></a>1-8 去掉重复的数据</h2><blockquote><p>在一大堆数据中找出重复的是一件经常要做的事情。现在，我们要处理许多整数，在这些整数中，可能存在重复的数据。你要写一个程序来做这件事情，读入数据，检查是否有重复的数据。如果有，去掉所有重复的数字。最后按照输入顺序输出没有重复数字的数据。所有重复的数字只保留第一次出现的那份。</p></blockquote><p><em><strong>输入格式:</strong></em><br>你的程序首先会读到一个正整数 n，1≤n≤100000。<br>然后是 n 个整数，这些整数的范围是 [1, 100000]。</p><p><em><strong>输出格式:</strong></em><br>在一行中按照输入顺序输出去除重复之后的数据。每两个数据之间有一个空格，行首尾不得有多余空格。</p><p><strong>输入样例:</strong><br>5<br>1 2 2 1 4<br><strong>输出样例:</strong><br>1 2 4</p><ul><li>题目中数据不大，可以开一个数组，输出答案后，变动数组的值，使其不再输出<br>同样注意空格问题！<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,x,arr[100005]&#x3D;&#123;0&#125;,num&#x3D;1;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;x);        if(arr[x]&#x3D;&#x3D;0&amp;&amp;num)&#123;            printf(&quot;%d&quot;,x);            num&#x3D;0;        &#125;        else if(arr[x]&#x3D;&#x3D;0)&#123;            printf(&quot; %d&quot;,x);        &#125;        arr[x]++;&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="进阶题"><a href="#进阶题" class="headerlink" title="进阶题"></a>进阶题</h1><h2 id="2-1-聚餐"><a href="#2-1-聚餐" class="headerlink" title="2-1 聚餐"></a>2-1 聚餐</h2><blockquote><p>有一个班有 n 个人， 从 1∼n 编号。这学期班里一共举行了 m 次聚餐，第i 次聚餐有 k i​个人参加。如果两名同学参加过同一场聚餐，那么我们就说这两个同学是熟悉的。现在给你q次询问，每个询问包含两个同学的编号a、b，问同学a和同学b是否熟悉。</p></blockquote><p><em><strong>输入格式</strong></em><br>第一行三个整数n,m,q(1&lt;=n,m,q&lt;=100)。分别代表同学人数，聚餐次数和询问次数。<br>接下来m行，每行第一个数 ki代表这次聚餐的人数，后面是 k i个同学的编号。<br>接下来 q行，每行两个整数 x和 y代表两个同学的编号。(x!=y)</p><p><em><strong>输出格式</strong></em><br>输出包含 q行，每行对应一个询问的答案，如果同学a和同学b是熟悉的，输出 YES；否则输出 NO 。</p><p><strong>样例输入</strong><br>3 2 2<br>2 1 2<br>2 1 3<br>1 2<br>2 3<br><strong>样例输出</strong><br>YES<br>NO<br><strong>提示</strong><br>样例中，共有3名学生，2场聚餐，2次询问<br>第一次聚餐有2名同学参加，分别是同学1和同学2<br>第二次聚餐有2名同学参加，分别是同学2和同学3<br>第一次询问，同学1和同学2都参加过第一场聚餐，所以输出YES<br>第二次询问，同学2和同学3没有参加过同一场聚餐，所以输出NO</p><ul><li>每次输入记录在arr里，同时使二维数组brr[arr[num1]][arr[num2]]和brr[arr[num2]][arr[num1]]的方式记录和判断两位同学是否熟悉<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,m,q,num1,num2,num3;    int arr[105],brr[105][105];    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;q);    while(m--)&#123;        scanf(&quot;%d&quot;,&amp;num1);        for(int i&#x3D;1;i&lt;&#x3D;num1;i++)&#123;            scanf(&quot;%d&quot;,&amp;arr[i]);        &#125;        for(int i&#x3D;1;i&lt;&#x3D;num1;i++)&#123;            for(int j&#x3D;i+1;j&lt;&#x3D;num1;j++)&#123;                brr[arr[i]][arr[j]]&#x3D;brr[arr[j]][arr[i]]&#x3D;1;            &#125;        &#125;    &#125;        while(q--)&#123;            scanf(&quot;%d%d&quot;,&amp;num2,&amp;num3);            puts(brr[num2][num3]?&quot;YES&quot;:&quot;NO&quot;);        &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-2-捡到两个字符串"><a href="#2-2-捡到两个字符串" class="headerlink" title="2-2 捡到两个字符串"></a>2-2 捡到两个字符串</h2><blockquote><p>小孤独总是喜欢低着头走路，因此经常捡到奇怪的东西，这天她捡到了两只字符串。给出两个由小写字母组成的字符串，一个整数m，以及m个由26个不同的小写字母构成的字符串作代表的新字母表，字符大小关系是按照顺序从小到大。请按照新的字母表以字典序的比较方法来比较，输出较小的字符串，若相同输出任意一个。字典序比较的解释：一个字符串小于另一个字符串，当且仅当以下情况之一成立<br>1.a是b的前缀，且a!=b。<br>2.在a和b不同的第一个位置，字符串a有一个字母在字母表中出现的时间比b中的相应字母早。<br>例如：按照正常的字母表abcdefghijklmnopqrstuvwxyz字符大小从小到大来比较，abc&lt;bcd , aa&lt;aaa , aab&gt;aaa。</p></blockquote><p><em><strong>输入格式</strong></em><br>前两行分别为两个字符串s1,s2(1&lt;=∣s∣&lt;=10000)<br>第三行为一个整数 m，代表给出m个新的字母表。(1&lt;=m&lt;=100)<br>接下来m行为m个字母表。</p><p><em><strong>输出格式</strong></em><br>对于每一个字母表输出相对应的较小的字符串。</p><p><strong>样例输入</strong><br>aaa<br>aab<br>2<br>abcdefghijklmnopqrstuvwxyz<br>bacdefghijklmnopqrstuvwxyz<br><strong>样例输出</strong><br>aaa<br>aab</p><p><strong>补充</strong><br>对于前10组测试用例，保证m=1且给定字母表为abcdefghijklmnopqrstuvwxyz，因此你只需要按照正常字典序进行比较</p><ul><li>本题使用映射的方法解决，将新的规则一个一个字符的转化为数字储存<pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,flag&#x3D;0,ys[200];&#x2F;&#x2F;ys&#x3D;映射    char arr[1000005],brr[1000005],neww[27];&#x2F;&#x2F;neww&#x3D;新规则    scanf(&quot;%s&quot;,arr);    scanf(&quot;%s&quot;,brr);    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%s&quot;,neww);        for(int j&#x3D;0;neww[j];j++)&#123;            ys[neww[j]]&#x3D;j;  &#x2F;&#x2F;映射与数字顺序对应        &#125;        for(int i&#x3D;0;arr[i]&amp;&amp;brr[i];i++)&#123;            if(ys[arr[i]]&lt;ys[brr[i]])&#123;                flag&#x3D;1;                break;            &#125;            else if(ys[arr[i]]&gt;ys[brr[i]])&#123;                flag&#x3D;2;                break;            &#125;        &#125;            if(flag&#x3D;&#x3D;1)                printf(&quot;%s\n&quot;,arr);            else if(flag&#x3D;&#x3D;2)                printf(&quot;%s\n&quot;,brr);            else&#123;                if(strlen(arr)&lt;strlen(brr))                    printf(&quot;%s\n&quot;,arr);                else                    printf(&quot;%s\n&quot;,brr);            &#125;        &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-3-打印菱形-Hard-ver"><a href="#2-3-打印菱形-Hard-ver" class="headerlink" title="2-3 打印菱形 (Hard-ver)"></a>2-3 打印菱形 (Hard-ver)</h2><blockquote><p>给定一个 n ，代表菱形的边长，请输出要求大小的图形（详见样例）。</p></blockquote><p><em><strong>输入格式</strong></em><br>输入一行一个整数 n(2&lt;=n&lt;=100) ，代表菱形的边长（数据保证n为偶数）。</p><p><em><strong>输出格式</strong></em><br>输出见样例：</p><p><strong>样例输入</strong><br><strong>样例输出</strong><br><img src="/2022/12/11/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%A2%98%E8%A7%A3/0004.png" alt="题目图片"></p><ul><li>热知识：输出“\”需要“\”<pre class="line-numbers language-none"><code class="language-none">int main()&#123;int n;scanf(&quot;%d&quot;,&amp;n);&#x2F;&#x2F; 上半未重合部分for(int i&#x3D;1;i&lt;&#x3D;n&#x2F;2;i++)&#123;for(int j&#x3D;1;j&lt;&#x3D;n-i;j++)    printf(&quot; &quot;);printf(&quot;&#x2F;&quot;);for(int j &#x3D; 1;j&lt;&#x3D;2*(i-1);j++)    printf(&quot; &quot;);printf(&quot;\\&quot;);for(int j &#x3D; 1;j&lt;&#x3D;n-(i*2-1);j++)    printf(&quot; &quot;);printf(&quot;&#x2F;&quot;);for(int j &#x3D; 1;j&lt;&#x3D;2*(i-1);j++)    printf(&quot; &quot;);printf(&quot;\\&quot;);puts(&quot;&quot;);&#125;&#x2F;&#x2F; 上半重合部分for(int i&#x3D;n&#x2F;2+1;i&lt;&#x3D;n;i++)&#123;for(int j&#x3D;1;j&lt;&#x3D; n-i;j++)printf(&quot; &quot;);    printf(&quot;&#x2F;&quot;);for(int j&#x3D;1;j&lt;&#x3D;n;j++)printf(&quot; &quot;);    printf(&quot;&#x2F;&quot;);for(int j&#x3D;1;j&lt;&#x3D;2*(i-1);j++)printf(&quot; &quot;);    printf(&quot;\\&quot;);puts(&quot;&quot;);&#125;&#x2F;&#x2F;下半重合部分for(int i&#x3D;1;i&lt;&#x3D;n&#x2F;2;i++)&#123;for(int j&#x3D;1;j&lt;&#x3D;i-1; j++)printf(&quot; &quot;);    printf(&quot;\\&quot;);for(int j &#x3D; 1;j&lt;&#x3D;n;j++)printf(&quot; &quot;);    printf(&quot;\\&quot;);for(int j&#x3D;1;j&lt;&#x3D;2*(n-i);j++) printf(&quot; &quot;);    printf(&quot;&#x2F;&quot;);puts(&quot;&quot;);&#125;&#x2F;&#x2F;下半未重合部分for (int i&#x3D;n&#x2F;2+1;i&lt;&#x3D;n;i++)&#123;for (int j&#x3D;1;j&lt;&#x3D; i-1;j ++ )printf(&quot; &quot;);    printf(&quot;\\&quot;);for (int j&#x3D;1;j&lt;&#x3D;2*(n-i);j++)printf(&quot; &quot;);    printf(&quot;&#x2F;&quot;);for (int j&#x3D;1;j&lt;&#x3D;n-(2*(n-i)+1);j++)printf(&quot; &quot;);    printf(&quot;\\&quot;);for (int j&#x3D;1;j&lt;&#x3D;2*(n-i);j++)printf(&quot; &quot;);    printf(&quot;&#x2F;&quot;);puts(&quot;&quot;);&#125;return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><mark>最后四题就不做总结了，为什么捏？大家看看提交率和通过率就知道了。。。<mark><br><img src="/2022/12/11/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E9%A2%98%E8%A7%A3/0003.png" alt="题目图片"></mark></mark></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经典题目</title>
      <link href="/2022/12/09/%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/"/>
      <url>/2022/12/09/%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<p>这里记录了一些让我在做题时遇见的自感比较经典且容易出错的题目。</p><h1 id="数组元素循环右移问题"><a href="#数组元素循环右移问题" class="headerlink" title="数组元素循环右移问题"></a>数组元素循环右移问题</h1><blockquote><p>一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置，即将最后M个数循环移至最前面的M个位置。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？</p></blockquote><p><em><strong>输入格式:</strong></em><br>每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。</p><p><em><strong>输出格式:</strong></em><br>在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。</p><p><strong>输入样例:</strong><br>6 2<br>1 2 3 4 5 6<br><strong>输出样例:</strong><br>5 6 1 2 3 4</p><p><mark>这是我原来的代码<mark>：</mark></mark></p><pre class="line-numbers language-none"><code class="language-none">#include&lt;stdio.h&gt;&#x2F;&#x2F;我的方法是让所有的数组向后移动，再讲最后的几个挪到前面来int main()&#123;int m,n;scanf(&quot;%d%d&quot;,&amp;m,&amp;n);int arr[m];for(int i&#x3D;0;i&lt;m;i++)&#123;scanf(&quot;%d&quot;,&amp;arr[i]);&#125;for(int i&#x3D;0;i&lt;n;i++)&#123;int x&#x3D;arr[m-1];for(int j&#x3D;0;j&lt;&#x3D;m;j++)&#123;arr[m-j]&#x3D;arr[m-j-1];&#125;arr[0]&#x3D;x;&#125;for(int i&#x3D;0;i&lt;m;i++)&#123;printf(&quot;%d&quot;,arr[i]);if(i!&#x3D;m-1)            printf(&quot; &quot;); &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><mark>这是老师的代码<mark>：</mark></mark></p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;通过取余的方式处理数据并直接输出，省时省力！#include &lt;stdio.h&gt;int main() &#123;    int i,n,k,arr[101];    scanf(&quot;%d%d&quot;,&amp;n,&amp;k);    for(i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);    &#125;    k&#x3D;k%n;    &#x2F;&#x2F;防止右移长度超过数组长度    for(i&#x3D;n-k;i&lt;n-k+n;i++)&#123;        if(i&#x3D;&#x3D;n-k)            printf(&quot;%d&quot;,arr[i%n]);        else            printf(&quot; %d&quot;,arr[i%n]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="最长字符子串"><a href="#最长字符子串" class="headerlink" title="最长字符子串"></a>最长字符子串</h1><blockquote><p>对给定的字符串，本题要求你输出最长对称子串的长度。例如，给定<strong>Is PAT&amp;TAP symmetric?<strong>，最长对称子串为</strong>s PAT&amp;TAP s</strong>，于是你应该输出<strong>11</strong>。</p></blockquote><p><em><strong>输入格式：</strong></em><br>输入在一行中给出长度不超过1000的非空字符串。<br><em><strong>输出格式：</strong></em><br>在一行中输出最长对称子串的长度。</p><p><strong>输入样例：</strong><br>Is PAT&amp;TAP symmetric?<br><strong>输出样例：</strong><br>11</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main() &#123;    int i,k,len,max&#x3D;0;    char arr[1005];    gets(arr);    for(i&#x3D;0;arr[i]!&#x3D;&#39;\0&#39;;i++)&#123;        k&#x3D;1;        len&#x3D;1;        while(i&gt;&#x3D;k&amp;&amp;arr[i+k]!&#x3D;&#39;\0&#39;&amp;&amp;arr[i-k]&#x3D;&#x3D;arr[i+k])&#123;             &#x2F;&#x2F;不是第一个数据&amp;&amp;不越界&amp;&amp;前后相等（奇数情况）            len+&#x3D;2;            k++;        &#125;        if(len&gt;max)            max&#x3D;len;        k&#x3D;1;        len&#x3D;0;        while(i+1&gt;&#x3D;k&amp;&amp;arr[i+k]!&#x3D;&#39;\0&#39;&amp;&amp;arr[i-k+1]&#x3D;&#x3D;arr[i+k])&#123;            &#x2F;&#x2F;不越界&amp;&amp;前后相等（偶数情况）            len+&#x3D;2;            k++;        &#125;        if(len&gt;max)            max&#x3D;len;    &#125;    printf(&quot;%d&quot;,max);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="切割绳子"><a href="#切割绳子" class="headerlink" title="切割绳子"></a>切割绳子</h1><blockquote><p>现有 N 条绳子，它们的长度分别为 L1、L2、L3、L4······，如果从它们中切割出 K 条长度相同的绳子，这 K 条绳子每条最长能有多长?</p></blockquote><p><em><strong>输入格式:</strong></em><br>第一行两个整数n和k（1&lt;n&lt;10000;1&lt;k&lt;10000）。<br>接下来n行，描述了每条绳子的长度L,L也是整数。</p><p><em><strong>输出格式:</strong></em><br>切割后每条绳子的最大长度。</p><p><strong>输入样例:</strong><br>4 11<br>802<br>743<br>457<br>539<br><strong>输出样例:</strong><br>200</p><pre class="line-numbers language-none"><code class="language-none"><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>22级天梯赛热身心得</title>
      <link href="/2022/12/08/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%83%AD%E8%BA%AB%E5%BF%83%E5%BE%97/"/>
      <url>/2022/12/08/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%83%AD%E8%BA%AB%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<p>今天在打完热身赛补题时发现一处以前没注意到的地方，白白浪费了两个小时进行debug，这里记录一下：</p><h2 id="2-1-有理数均值"><a href="#2-1-有理数均值" class="headerlink" title="2-1 有理数均值"></a>2-1 有理数均值</h2><blockquote><p>本题要求编写程序，计算N个有理数的平均值。<br>输入格式：输入第一行给出正整数N（≤100）；第二行中按照a1/b1 a2/b2 …的格式给出N个分数形式的有理数，其中分子和分母全是整形范围内的整数；如果是负数，则负号一定出现在最前面。<br>输出格式：在一行中按照a/b的格式输出N个有理数的平均值。注意必须是该有理数的最简分数形式，若分母为1，则只输出分子。</p></blockquote><p><strong>输入样例1：</strong><br>4<br>1/2 1/6 3/6 -5/10<br><strong>输出样例1：</strong><br>1/6<br><strong>输入样例2：</strong><br>2<br>4/3 2/3<br><strong>输出样例2：</strong><br>1</p><pre class="line-numbers language-none"><code class="language-none">int gcd(int x,int y);int main()&#123;    int n,fenzi&#x3D;0,fenmu&#x3D;1,up,down,i;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&#x2F;%d&quot;,&amp;up,&amp;down);        if(up&#x3D;&#x3D;0)            continue;        fenzi&#x3D;up*fenmu+fenzi*down;   &#x2F;&#x2F;分子接收数据        fenmu*&#x3D;down;   &#x2F;&#x2F;分母接收数据        if(i&#x3D;&#x3D;n-1)            fenmu*&#x3D;n;   &#x2F;&#x2F;求平均数则 分母*n        int max_gongyue&#x3D;gcd(fenzi,fenmu);   &#x2F;&#x2F;约分        fenzi&#x2F;&#x3D;max_gongyue;        fenmu&#x2F;&#x3D;max_gongyue;    &#125;    if(fenzi&#x3D;&#x3D;0)printf(&quot;0&quot;);else if(fenmu&#x3D;&#x3D;1)        printf(&quot;%d&quot;,fenzi);elseprintf(&quot;%d&#x2F;%d&quot;,fenzi,fenmu);    return 0;&#125;int gcd(int x,int y)&#123;    if(y&#x3D;&#x3D;0)        return x;    else        return gcd(y,x%y);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-伙伴"><a href="#3-2-伙伴" class="headerlink" title="3-2 伙伴"></a>3-2 伙伴</h2><blockquote><p>近来，程序社团开始“创客”——用程序来开发一种“找伙伴的数字游戏”。这个伙伴游戏将玩家分为A和B二组。每组每个玩家可以得到一个数字号码。<br>游戏规则是这样的：A组里的每个人的数字与B组里每个人的数字进行“数字配对”——即加法运算，若运算的结果恰巧是B组内其他玩家手捏的数字号码，那么游戏就可以累计一个分值，这个分值就是B组内这个“恰巧”的数字号码。当然，在B组内“恰巧”的数字号码可能不止一个，游戏允许再次累计。<br>比如加法运算后的“恰巧”的数字是3，而B组内共有2个玩家捏有此数字，那么本组就可以得到6分。<br>你是游戏的开发者之一，你需要迅速计算出找伙伴游戏的最终得分。<br><em><strong>输入格式:</strong></em><br>第一行有二个数字n和m，分别表示A组和B组的人数。<br>第二行有n个整数ai，每个整数之间有一个空格，表示n个玩家手中的数字号码。<br>第三行有m个整数bi，每个整数之间有一个空格，表示m个玩家手中的数字号码。</p></blockquote><p><em><strong>输出格式:</strong></em><br>只有一行，一个数字s，表示游戏的最终分数。</p><p><strong>输入样例1:</strong><br>3 3<br>3 5 6<br>2 7 4<br><strong>输出样例1:</strong><br>14<br><strong>样例说明：</strong><br>A组内捏有”3”的玩家与B组内三个玩家进行“数字配对”，遇4时相加后, 发现B组内有一个恰巧的数字“7”;<br>A组内捏有“5”的玩家与B组内三个玩家进行“数字配对”，遇2相加后, 发现B组内有一个恰巧的数字“7”;<br>当A组内捏有“6”的玩家与B组内三个玩家进行“数字配对”，无论与谁的数字相加，都没有在B组发现一个恰巧的数字;<br>因此最终结果是：7+7=14。</p><p><strong>输入样例2:</strong><br>3 3<br>2 5 2<br>6 8 8<br><strong>输出样例2:</strong><br>32<br><strong>样例说明：</strong><br>A组第1玩家捏有数字”2”,与B组进行“数字配对”时，得分8+8;<br>A组第2玩家捏有数字”5”，与B组进行“数字配对”时，得分0;<br>A组第3玩家捏有数字”2”，与B组进行“数字配对”时，得分8+8;<br>因此最终得分为：8+8+8+8。</p><p><strong>【数据规模】</strong><br>30%的数据，1&lt;=n,m&lt;=3，1&lt;=ai,bi&lt;=100<br>50%数据，1&lt;=n,m&lt;=100，1&lt;=ai,bi&lt;=100<br>70%数据，1&lt;=n,m&lt;=10000，1&lt;=ai,bi&lt;=100<br>100%数据，1&lt;=n,m&lt;=100000，1&lt;=ai,bi&lt;=100</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int m,n,x,y;    long long sum&#x3D;0;    scanf(&quot;%d %d&quot;,&amp;m,&amp;n);    int arr[100000]&#x3D;&#123;0&#125;,brr[100000]&#x3D;&#123;0&#125;;    for(int i&#x3D;0;i&lt;m;i++)&#123;        scanf(&quot;%d&quot;,&amp;x);        arr[x]++;    &#125;    for(int i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;y);        brr[y]++;    &#125;    for(int i&#x3D;1;i&lt;&#x3D;100;i++)&#123;        for(int j&#x3D;1;i+j&lt;&#x3D;100;j++)&#123;            if(arr[i]&gt;0&amp;&amp;brr[j]&gt;0&amp;&amp;brr[i+j]&gt;0)&#123;                sum+&#x3D;arr[i]*brr[j]*brr[i+j]*(i+j);                   &#x2F;&#x2F;A中符合条件的卡片数*B中符合条件的卡片数*B拿到正确结果的人数*（应得的分数）            &#125;        &#125;    &#125;    printf(&quot;%lld&quot;,sum);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="基础题"><a href="#基础题" class="headerlink" title="基础题"></a>基础题</h1><h2 id="1-1-重要的话说三遍"><a href="#1-1-重要的话说三遍" class="headerlink" title="1-1 重要的话说三遍"></a>1-1 重要的话说三遍</h2><blockquote><p>这道超级简单的题目没有任何输入。你只需要把这句很重要的话 —— “I’m gonna WIN!”——连续输出三遍就可以了。注意每遍占一行，除了每行的回车不能有任何多余字符。</p></blockquote><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    for(int i&#x3D;0;i&lt;3;i++)&#123;        printf(&quot;I&#39;m gonna WIN!&quot;);        if(i!&#x3D;2)            printf(&quot;\n&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-整数积"><a href="#1-2-整数积" class="headerlink" title="1-2 整数积"></a>1-2 整数积</h2><blockquote><p>小明没带草稿纸，心算搞不定整数的乘积，只有请你帮忙设计程序来求输入的任意三个整数的乘积。</p></blockquote><p><em><strong>输入格式:</strong></em><br>输入三个由空格隔开的整数a,b,c，(-1000 &lt; a , b , c &lt; 1000 )</p><p><em><strong>输出格式:</strong></em><br>输出三个整数的乘积</p><p><strong>输入样例:</strong><br>1 2 3<br><strong>输出样例:</strong><br>6</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    long long a,b,c,d;    scanf(&quot;%lld%lld%lld&quot;,&amp;a,&amp;b,&amp;c);    d&#x3D;a*b*c;    printf(&quot;%lld&quot;,d);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-三天打鱼两天晒网"><a href="#1-3-三天打鱼两天晒网" class="headerlink" title="1-3 三天打鱼两天晒网"></a>1-3 三天打鱼两天晒网</h2><blockquote><p>中国有句俗语叫“三天打鱼两天晒网”。假设某人从某天起，开始“三天打鱼两天晒网”，问这个人在以后的第N天中是“打鱼”还是“晒网”？</p></blockquote><ul><li>以5为一个循环，然后正常判断即可</li></ul><p><em><strong>输入格式：</strong></em><br>输入在一行中给出一个不超过1000的正整数N。</p><p><em><strong>输出格式：</strong></em><br>在一行中输出此人在第N天中是“Fishing”（即“打鱼”）还是“Drying”（即“晒网”），并且输出“in day N”。</p><p><strong>输入样例1：</strong><br>103<br><strong>输出样例1：</strong><br>Fishing in day 103<br><strong>输入样例2：</strong><br>34<br><strong>输出样例2：</strong><br>Drying in day 34</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,x;    scanf(&quot;%d&quot;,&amp;n);    x&#x3D;n%5;    if(x&gt;0&amp;&amp;x&lt;&#x3D;3)        printf(&quot;Fishing in day %d&quot;,n);    else        printf(&quot;Drying in day %d&quot;,n);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-用天平找小球"><a href="#1-4-用天平找小球" class="headerlink" title="1-4 用天平找小球"></a>1-4 用天平找小球</h2><blockquote><p>三个球A、B、C，大小形状相同且其中有一个球与其他球重量不同。要求找出这个不一样的球。</p></blockquote><p><em><strong>输入格式：</strong></em><br>输入在一行中给出3个正整数，顺序对应球A、B、C的重量。</p><p><em><strong>输出格式：</strong></em><br>在一行中输出唯一的那个不一样的球。</p><p><strong>输入样例：</strong><br>1 1 2<br><strong>输出样例：</strong><br>C</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int a,b,c;    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);    if(a&#x3D;&#x3D;b)        printf(&quot;C&quot;);    else if(a&#x3D;&#x3D;c)        printf(&quot;B&quot;);    else if(b&#x3D;&#x3D;c)        printf(&quot;A&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-100以内的加法"><a href="#1-5-100以内的加法" class="headerlink" title="1-5 100以内的加法"></a>1-5 100以内的加法</h2><blockquote><p>小明刚上小学一年级，数学老师刚刚教会了100以内的整数加法运算，数学老师期中测试出了一道题，题目为求两个整数之间的所有整数之和，包括边界整数值，小明很是为难？现要你编程帮小明解决问题。</p></blockquote><p><em><strong>输入格式:</strong></em><br>在一行中输入两个边界整数值m,n(1&lt;= m &lt;= n &lt;=100)，中间以空格隔开。</p><p><em><strong>输出格式:</strong></em><br>在一行中输出m到n之间的所有整数和。</p><p><strong>输入样例:</strong><br>2 7<br><strong>输出样例:</strong><br>27</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int a,b,sum&#x3D;0;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    for(int i&#x3D;a;i&lt;&#x3D;b;i++)&#123;        sum+&#x3D;i;    &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-6-循环的统计"><a href="#1-6-循环的统计" class="headerlink" title="1-6 循环的统计"></a>1-6 循环的统计</h2><blockquote><p>在墙角堆放着一堆完全相同的正方体小木块，从上往下数起，第一层是1块，第二层是3块，第三层是6块…… 因为木块堆得实在是太有规律了，你只要知道它的层数就可以计算所有木块的数量了。<br><img src="/2022/12/08/22%E7%BA%A7%E5%A4%A9%E6%A2%AF%E8%B5%9B%E7%83%AD%E8%BA%AB%E5%BF%83%E5%BE%97/0001.png" alt="题目图片"></p></blockquote><ul><li>观察可得，第i层比上一层多了i个方块。</li></ul><p><em><strong>输入格式:</strong></em><br>只有一个整数 n ，表示这堆小木块的层数，已知1 &lt;= n &lt;= 100 。</p><p><em><strong>输出格式:</strong></em><br>只有一个整数，表示这堆小木块的总数量。</p><p><strong>输入样例:</strong><br>5<br><strong>输出样例:</strong><br>35</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,sum1&#x3D;0,sum&#x3D;0;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;1;i&lt;&#x3D;n;i++)&#123;        sum1+&#x3D;i;        sum+&#x3D;sum1;    &#125;    printf(&quot;%d&quot;,sum);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-7-求特殊方程的正整数解"><a href="#1-7-求特殊方程的正整数解" class="headerlink" title="1-7 求特殊方程的正整数解"></a>1-7 求特殊方程的正整数解</h2><blockquote><p>本题要求对任意给定的正整数N，求方程X^2+Y^2=N的全部正整数解。</p></blockquote><ul><li>数据较小，嵌套枚举即可</li></ul><p><em><strong>输入格式：</strong></em><br>输入在一行中给出正整数N（≤10000）。</p><p><em><strong>输出格式：</strong></em><br>输出方程X^2+Y^2=N的全部正整数解，其中X≤Y。每组解占1行，两数字间以1空格分隔，按X的递增顺序输出。如果没有解，则输出No Solution。</p><p><strong>输入样例1：</strong><br>884<br><strong>输出样例1：</strong><br>10 28<br>20 22<br><strong>输入样例2：</strong><br>11<br><strong>输出样例2：</strong><br>No Solution</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,flag&#x3D;0;    scanf(&quot;%d&quot;,&amp;n);    for(int i&#x3D;0;i&lt;&#x3D;sqrt(n);i++)&#123;        for(int j&#x3D;0;j&lt;sqrt(n);j++)&#123;            if(i*i+j*j&#x3D;&#x3D;n&amp;&amp;i&lt;&#x3D;j)&#123;                printf(&quot;%d %d\n&quot;,i,j);                flag&#x3D;1;            &#125;        &#125;    &#125;    if(!flag)&#123;        printf(&quot;No Solution&quot;);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-8-猜数字游戏"><a href="#1-8-猜数字游戏" class="headerlink" title="1-8 猜数字游戏"></a>1-8 猜数字游戏</h2><blockquote><p>猜数字游戏是令游戏机随机产生一个100以内的正整数，用户输入一个数对其进行猜测，需要你编写程序自动对其与随机产生的被猜数进行比较，并提示大了（“Too big”），还是小了（“Too small”），相等表示猜到了。如果猜到，则结束程序。程序还要求统计猜的次数，如果1次猜出该数，提示“Bingo!”；如果3次以内猜到该数，则提示“Lucky You!”；如果超过3次但是在N（&gt;3）次以内（包括第N次）猜到该数，则提示“Good Guess!”；如果超过N次都没有猜到，则提示“Game Over”，并结束程序。如果在到达N次之前，用户输入了一个负数，也输出“Game Over”，并结束程序。</p></blockquote><ul><li>看着唬人其实很普通的一道题，准确处理好每个变量关系即可</li></ul><p><em><strong>输入格式:</strong></em><br>输入第一行中给出两个不超过100的正整数，分别是游戏机产生的随机数、以及猜测的最大次数N。最后每行给出一个用户的输入，直到出现负数为止。</p><p><em><strong>输出格式:</strong></em><br>在一行中输出每次猜测相应的结果，直到输出猜对的结果或“Game Over”则结束。</p><p><strong>输入样例:</strong><br>58 4<br>70<br>50<br>56<br>58<br>60<br>-2</p><p><strong>输出样例:</strong><br>Too big<br>Too small<br>Too small<br>Good Guess!</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,t,x,flag&#x3D;0,num&#x3D;0;    scanf(&quot;%d %d&quot;,&amp;n,&amp;t);    while(scanf(&quot;%d&quot;,&amp;x)!&#x3D;EOF)&#123;        num++;        if((num&lt;&#x3D;t&amp;&amp;x&lt;0)||(num&gt;t))&#123;            printf(&quot;Game Over\n&quot;);            break;        &#125;        if(x&gt;n)&#123;            printf(&quot;Too big\n&quot;);            flag++;        &#125;        else if(x&lt;n)&#123;            printf(&quot;Too small\n&quot;);            flag++;        &#125;        else&#123;            if(flag&#x3D;&#x3D;0)&#123;                printf(&quot;Bingo!\n&quot;);                break;            &#125;            else if(flag&lt;&#x3D;2&amp;&amp;flag&gt;&#x3D;1)&#123;                printf(&quot;Lucky You!\n&quot;);                break;            &#125;            else if(flag&gt;2&amp;&amp;flag&lt;t)&#123;                printf(&quot;Good Guess!\n&quot;);                break;            &#125;            else&#123;                printf(&quot;Game Over\n&quot;);                break;            &#125;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="进阶题"><a href="#进阶题" class="headerlink" title="进阶题"></a>进阶题</h1><h2 id="2-1-有理数均值-1"><a href="#2-1-有理数均值-1" class="headerlink" title="2-1 有理数均值"></a>2-1 有理数均值</h2><ul><li>见文章开头</li></ul><h2 id="2-2-求矩阵的局部极大值"><a href="#2-2-求矩阵的局部极大值" class="headerlink" title="2-2 求矩阵的局部极大值"></a>2-2 求矩阵的局部极大值</h2><blockquote><p>给定M行N列的整数矩阵A，如果A的非边界元素A[i][j]大于相邻的上下左右4个元素，那么就称元素A[i][j]是矩阵的局部极大值。本题要求给定矩阵的全部局部极大值及其所在的位置。</p></blockquote><ul><li>找的时候舍弃二维数组的最外一层，判断与四周的关系即可</li></ul><p><em><strong>输入格式：</strong></em><br>输入在第一行中给出矩阵A的行数M和列数N（3≤M,N≤20）；最后M行，每行给出A在该行的N个元素的值。数字间以空格分隔。</p><p><em><strong>输出格式：</strong></em><br>每行按照“元素值 行号 列号”的格式输出一个局部极大值，其中行、列编号从1开始。要求按照行号递增输出；若同行有超过1个局部极大值，则该行按列号递增输出。若没有局部极大值，则输出“None 总行数 总列数”。</p><p><strong>输入样例1：</strong><br>4 5<br>1 1 1 1 1<br>1 3 9 3 1<br>1 5 3 5 1<br>1 1 1 1 1<br><strong>输出样例1：</strong><br>9 2 3<br>5 3 2<br>5 3 4<br><strong>输入样例2：</strong><br>3 5<br>1 1 1 1 1<br>9 3 9 9 1<br>1 5 3 5 1<br><strong>输出样例2：</strong><br>None 3 5</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int m,n,flag&#x3D;1;    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    int arr[m+1][n+1];    for(int i&#x3D;0;i&lt;m;i++)&#123;        for(int j&#x3D;0;j&lt;n;j++)&#123;            scanf(&quot;%d&quot;,&amp;arr[i][j]);        &#125;    &#125;    for(int i&#x3D;1;i&lt;m-1;i++)&#123;        for(int j&#x3D;1;j&lt;n-1;j++)&#123;            if((arr[i][j]&gt;arr[i-1][j])&amp;&amp;(arr[i][j]&gt;arr[i][j-1])&amp;&amp;(arr[i][j]&gt;arr[i+1][j])&amp;&amp;(arr[i][j]&gt;arr[i][j+1]))&#123;                printf(&quot;%d %d %d\n&quot;,arr[i][j],i+1,j+1);                flag&#x3D;0;            &#125;        &#125;    &#125;    if(flag)&#123;        printf(&quot;None %d %d&quot;,m,n);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-傻傻分不清楚"><a href="#2-3-傻傻分不清楚" class="headerlink" title="2-3 傻傻分不清楚"></a>2-3 傻傻分不清楚</h2><blockquote><p>有一次小Y的键盘的大写键坏了（打字母随机大小写），但他现在需要照着打几段字符串（只有英文字母），不过他有时候会有点粗心会打错字母。然后现在我需要眼尖的你来帮帮我帮我找出他有没有粗心（只是大小写不同不算粗心），如果没有请你告诉我键盘一共坏了几次。</p></blockquote><ul><li>记得更新数组即可</li></ul><p><em><strong>输入格式:</strong></em><br>输入第一行给出正整数N，代表他接下来要打的字符串数量。<br>随后给出2N行字符串，两两对应。<br>每段字符串长度小于100。本题多组数据。</p><p><em><strong>输出格式:</strong></em><br>每两个字符串输出一行，如果他粗心了输出“NO!”，没有粗心输出“YES!”并在后面空一格输出键盘坏的次数</p><p><strong>输入样例:</strong><br>在这里给出一组输入。例如：<br>2<br>abcdfef<br>aBCdfef<br>c<br>c<br>1<br>qwer<br>QEWr<br><strong>输出样例:</strong><br>在这里给出相应的输出。例如：<br>YES! 2<br>YES! 0<br>NO!</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,flag&#x3D;0,i;    char arr[105],brr[105];    while(scanf(&quot;%d&quot;,&amp;n)!&#x3D;EOF)&#123;        scanf(&quot;%s%s&quot;,arr,brr);        for(i&#x3D;0;i&lt;strlen(arr);i++)&#123;                if((arr[i]&#x3D;&#x3D;brr[i]))                    continue;                else if((arr[i]-32&#x3D;&#x3D;brr[i])||(arr[i]+32&#x3D;&#x3D;brr[i]))&#123;                    flag++;                    continue;                &#125;                else&#123;                    printf(&quot;NO!\n&quot;);                    break;                &#125;        &#125;        if(i&#x3D;&#x3D;strlen(arr))&#123;            printf(&quot;YES! %d\n&quot;,flag);        &#125;        for(i&#x3D;0;i&lt;strlen(arr);i++)&#123;   &#x2F;&#x2F;记得更新数组            arr[i]&#x3D;0;            brr[i]&#x3D;0;        &#125;        flag&#x3D;0;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-谁先倒"><a href="#2-4-谁先倒" class="headerlink" title="2-4 谁先倒"></a>2-4 谁先倒</h2><blockquote><p>划拳是古老中国酒文化的一个有趣的组成部分。酒桌上两人划拳的方法为：每人口中喊出一个数字，同时用手比划出一个数字。如果谁比划出的数字正好等于两人喊出的数字之和，谁就输了，输家罚一杯酒。两人同赢或两人同输则继续下一轮，直到唯一的赢家出现。下面给出甲、乙两人的酒量（最多能喝多少杯不倒）和划拳记录，请你判断两个人谁先倒。</p></blockquote><ul><li>注意同输同赢时不要处理数据</li></ul><p><em><strong>输入格式：</strong></em><br>输入第一行先后给出甲、乙两人的酒量（不超过100的非负整数），以空格分隔。下一行给出一个正整数N（≤100），随后N行，每行给出一轮划拳的记录，格式为：<br><strong>甲喊 甲划 乙喊 乙划</strong><br>其中喊是喊出的数字，划是划出的数字，均为不超过100的正整数（两只手一起划）。</p><p><em><strong>输出格式：</strong></em><br>在第一行中输出先倒下的那个人：A代表甲，B代表乙。第二行中输出没倒的那个人喝了多少杯。题目保证有一个人倒下。注意程序处理到有人倒下就终止，后面的数据不必处理。</p><p><strong>输入样例：</strong><br>1 1<br>6<br>8 10 9 12<br>5 10 5 10<br>3 8 5 12<br>12 18 1 13<br>4 16 12 15<br>15 1 1 16<br><strong>输出样例：</strong><br>A<br>1</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int m,n,t,jh,jhw,yh,yhw,flag1&#x3D;0,flag2&#x3D;0;    scanf(&quot;%d%d&quot;,&amp;m,&amp;n);    scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        scanf(&quot;%d%d%d%d&quot;,&amp;jh,&amp;jhw,&amp;yh,&amp;yhw);        if(jhw&#x3D;&#x3D;jh+yh&amp;&amp;yhw!&#x3D;jh+yh)&#123;            flag1++;            &#125;        if(yhw&#x3D;&#x3D;jh+yh&amp;&amp;jhw!&#x3D;jh+yh)&#123;            flag2++;        &#125;        if(flag1&gt;m)&#123;            printf(&quot;A\n%d&quot;,flag2);            break;        &#125;        if(flag2&gt;n)&#123;            printf(&quot;B\n%d&quot;,flag1);            break;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="登顶题"><a href="#登顶题" class="headerlink" title="登顶题"></a>登顶题</h1><h2 id="3-1-帅到没朋友"><a href="#3-1-帅到没朋友" class="headerlink" title="3-1 帅到没朋友"></a>3-1 帅到没朋友</h2><blockquote><p>当芸芸众生忙着在朋友圈中发照片的时候，总有一些人因为太帅而没有朋友。本题就要求你找出那些帅到没有朋友的人。</p></blockquote><ul><li>当输入人数为1时不要处理，输出时注意5位格式！</li></ul><p><em><strong>输入格式：</strong></em><br>输入第一行给出一个正整数N（≤100），是已知朋友圈的个数；随后N行，每行首先给出一个正整数K（≤1000），为朋友圈中的人数，然后列出一个朋友圈内的所有人——为方便起见，每人对应一个ID号，为5位数字（从00000到99999），ID间以空格分隔；之后给出一个正整数M（≤10000），为待查询的人数；随后一行中列出M个待查询的ID，以空格分隔。</p><p>注意：没有朋友的人可以是根本没安装“朋友圈”，也可以是只有自己一个人在朋友圈的人。虽然有个别自恋狂会自己把自己反复加进朋友圈，但题目保证所有K超过1的朋友圈里都至少有2个不同的人。</p><p><strong>输出格式：</strong><br>按输入的顺序输出那些帅到没朋友的人。ID间用1个空格分隔，行的首尾不得有多余空格。如果没有人太帅，则输出No one is handsome。</p><p><strong>注意：同一个人可以被查询多次，但只输出一次。</strong></p><p><strong>输入样例1：</strong><br>3<br>3 11111 22222 55555<br>2 33333 44444<br>4 55555 66666 99999 77777<br>8<br>55555 44444 10000 88888 22222 11111 23333 88888<br><strong>输出样例1：</strong><br>10000 88888 23333<br><strong>输入样例2：</strong><br>3<br>3 11111 22222 55555<br>2 33333 44444<br>4 55555 66666 99999 77777<br>4<br>55555 44444 22222 11111<br><strong>输出样例2：</strong><br>No one is handsome</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;    int n,x,y,t,num,flag&#x3D;1;    int arr[100000]&#x3D;&#123;0&#125;;    scanf(&quot;%d&quot;,&amp;n);    for(int j&#x3D;0;j&lt;n;j++)&#123;        scanf(&quot;%d&quot;,&amp;x);        for(int i&#x3D;0;i&lt;x;i++)&#123;            scanf(&quot;%d&quot;,&amp;y);            if(x!&#x3D;1)            arr[y]++;        &#125;    &#125;    scanf(&quot;%d&quot;,&amp;t);    while(t--)&#123;        scanf(&quot;%d&quot;,&amp;num);        if(arr[num]&#x3D;&#x3D;0)&#123;            flag&#x3D;0;            printf(&quot;%05d&quot;,num);            if(t&gt;1)                printf(&quot; &quot;);            arr[num]&#x3D;1;        &#125;    &#125;    if(flag)            printf(&quot;No one is handsome&quot;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-伙伴-1"><a href="#3-2-伙伴-1" class="headerlink" title="3-2 伙伴"></a>3-2 伙伴</h2><ul><li>见文章开头</li></ul><h2 id="3-3-密文游戏"><a href="#3-3-密文游戏" class="headerlink" title="3-3 密文游戏"></a>3-3 密文游戏</h2><blockquote><p>JLU最近流行密文游戏。发送者把信息（原文）按约定的规则变成密文发给接收者,接收者拿到密文按解密规则得到原文。其它人不知道加密解密规则，即使拿到信息的密文，也无法得知原文。<br>小明是你的好朋友，想和你一起玩密文游戏。你俩约定了一个简单的加密解密方案：字符 0 映射字母 A，字符 1 映射字母 B，依次类推，字符 9 映射字母 J。例如：原文1314的密文为BDBE。<br>昨天，你给小明发了一条信息。由于未知原因，密文到小明那里发生了缺失。今天上课，你俩见面对照了原文和密文，发现密文丢失了若干字符。设原文S的长度为n，密文T的长度为m，小明突发奇想：对照原文，有多少种方案能把密文补全，字母数量和位置不同，都视为不同的方案。作为好友的你,帮他计算一下吧。</p></blockquote><p><em><strong>输入格式:</strong></em><br>第一行，原文S，长度为n(2≤n≤2000)。<br>第二行，密文T，长度为m(1≤m ≤ n-1 )。</p><p><em><strong>输出格式:</strong></em><br>一行，所求的方案数</p><p><strong>输入样例:</strong><br>在这里给出一组输入。例如：<br>1414<br>BE<br><strong>输出样例:</strong><br>在这里给出相应的输出。例如：<br>3<br><strong>样例说明</strong><br>样例中3种补全方案如下。（）中代表所补的密文。<br>BE(BE)<br>B(EB)E<br>(BE)BE</p><p><em><strong>解析还未出炉，先看看别的吧~</strong></em></p>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进制转换</title>
      <link href="/2022/12/04/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
      <url>/2022/12/04/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="十进制转d进制-d-lt-10"><a href="#十进制转d进制-d-lt-10" class="headerlink" title="十进制转d进制(d&lt;10)"></a>十进制转d进制(d&lt;10)</h2><p>原理很简单，按照计算方法算出每一位后存入数组，倒序输出即可~</p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;  int n,i&#x3D;0,x,j,d;  int arr[1000];  scanf(&quot;%d%d&quot;,&amp;n,&amp;d);  if(n&#x3D;&#x3D;0)    printf(&quot;0&quot;);  else&#123;  while(n&gt;0)&#123;        &#x2F;&#x2F;想不起来的话把d设成2自己代入一遍    x&#x3D;n%d;    n&#x2F;&#x3D;d;    arr[i]&#x3D;x;    i++;  &#125;  for(j&#x3D;i-1;j&gt;&#x3D;0;j--)&#123;    &#x2F;&#x2F;逆序输出    printf(&quot;%d&quot;,arr[j]);  &#125;  &#125;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="d进制转十进制（d-lt-10"><a href="#d进制转十进制（d-lt-10" class="headerlink" title="d进制转十进制（d&lt;10)"></a>d进制转十进制（d&lt;10)</h2><pre class="line-numbers language-none"><code class="language-none">int main()&#123;  int n,x&#x3D;1,num&#x3D;0,d;  scanf(&quot;%d%d&quot;,&amp;n,&amp;d);  while(n&gt;0)&#123;    num+&#x3D;(n%10)*x;    &#x2F;&#x2F;拨出最后一位乘以位权    n&#x2F;&#x3D;10;    &#x2F;&#x2F;舍弃最后一位    x*&#x3D;d;    &#x2F;&#x2F;位权增加  &#125;  printf(&quot;%d&quot;,num);  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="十进制转十六进制"><a href="#十进制转十六进制" class="headerlink" title="十进制转十六进制"></a>十进制转十六进制</h2><p>与前面的“十进制转d进制”差不多，只是用<em>字符数组</em>代替了<em>整型数组</em></p><pre class="line-numbers language-none"><code class="language-none">int main()&#123;  int n,i&#x3D;0,j;  char arr[1000],brr[20]&#x3D;&#123;&quot;0123456789ABCDEF&quot;&#125;;  scanf(&quot;%d&quot;,&amp;n);  if(n&#x3D;&#x3D;0)    printf(&quot;0&quot;);  else&#123;  while(n&gt;0)&#123;    arr[i]&#x3D;brr[n%16];    n&#x2F;&#x3D;16;    i++;  &#125;  for(j&#x3D;i-1;j&gt;&#x3D;0;j--)&#123;    printf(&quot;%c&quot;,arr[j]);  &#125;  &#125;  return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>在查找资料的时候发现C艹自带进制转换的函数，顺便记录一下~</p><blockquote><p>oct 是八进制形式<br> dec 是十进制形式<br> hex 是十六进制形式（setiosflags(ios::uppercase)可转换为大写输出）<br>C语言没有专门的二进制转换，故只能规定位数输出二进制</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;int main() &#123;    int n;    cin&gt;&gt;n;    cout&lt;&lt;bitset&lt;8&gt;(n)&lt;&lt;endl;    cout&lt;&lt;oct&lt;&lt;n&lt;&lt;endl;    cout&lt;&lt;dec&lt;&lt;n&lt;&lt;endl;    cout&lt;&lt;setiosflags(ios::uppercase)&lt;&lt;hex&lt;&lt;n&lt;&lt;endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>递归与递推</title>
      <link href="/2022/12/03/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/"/>
      <url>/2022/12/03/%E9%80%92%E5%BD%92%E4%B8%8E%E9%80%92%E6%8E%A8/</url>
      
        <content type="html"><![CDATA[<p>递归与递推是编程问题中重要的思想，如何更好的理解？看完这篇文章你可能会有收获。</p><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h2><blockquote><p>递归，就是在运行的过程中不断调用自己本身。可以分为“递”和“归”两个过程，“递”得到每一个小步的结果，再通过“归”将每次运算的结果结合起来。最后得到答案。</p></blockquote><h2 id="递归优缺点"><a href="#递归优缺点" class="headerlink" title="递归优缺点"></a>递归优缺点</h2><ul><li>优点：代码简解易懂，思维方式符合我们思考的逻辑。</li><li>缺点：运行效率低，需要调用很多栈来储存返回点和局部量等，容易造成栈溢出。</li></ul><h1 id="递推"><a href="#递推" class="headerlink" title="递推"></a>递推</h1><h2 id="递推定义"><a href="#递推定义" class="headerlink" title="递推定义"></a>递推定义</h2><blockquote><p>递推，就是从问题的初始条件出发，通过观察得出某种关系式，通过这个关系式推出各项结果。</p></blockquote><h2 id="递推优缺点"><a href="#递推优缺点" class="headerlink" title="递推优缺点"></a>递推优缺点</h2><ul><li>优点：很好的发挥了计算机重复计算的优点，不会像递推一样占用过多的内存空间。</li><li>缺点：想象不到递推的关系式，从源头上直接gg（doge 。</li></ul><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><h2 id="裴波那契数列"><a href="#裴波那契数列" class="headerlink" title="裴波那契数列"></a>裴波那契数列</h2><blockquote><p>有一对小兔子，从出生后第3个月起每个月都生一对兔子。小兔子长到第3个月后每个月又生一对兔子。按此规律，假设没有兔子死亡，第一个月有一对刚出生的小兔子，问第n个月有多少对兔子？</p></blockquote><p>在草稿纸上进行简单的演算，我们会发现:第一个月1对，第二个月1对，第三个月2对，第四个月3对，第五个月5对，第六个月8对，第七个月13对……<strong>从第三项开始，每个月的数量都是前两个月的和</strong></p><p>不难得出，<strong>当n&gt;=3时，本月兔子数量=上个月数量+上上个月数量</strong>。</p><p>递归、递推代码</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;math.h&gt;int digui(int n)    &#x2F;&#x2F;递归&#123;    if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)        return 1;    else        return (digui(n-1)+digui(n-2));&#125;int ditui(int n)    &#x2F;&#x2F;递推&#123;    int x&#x3D;1,y&#x3D;1,z;    if(n&#x3D;&#x3D;1||n&#x3D;&#x3D;2)        z&#x3D;1;    else &#123;        for(int i&#x3D;0;i&lt;n-2;i++)&#123;        z&#x3D;x+y;        x&#x3D;y;        y&#x3D;z;        &#125;    &#125;    return z;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;,&amp;n);    printf(&quot;%d\n&quot;,digui(n));    printf(&quot;%d\n&quot;,ditui(n));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高中往事回忆</title>
      <link href="/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/"/>
      <url>/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/</url>
      
        <content type="html"><![CDATA[<p><strong>后期会持续推出<del>敬请期待</del></strong></p><p><img src="/2022/11/30/%E9%AB%98%E4%B8%AD%E5%BE%80%E4%BA%8B%E5%9B%9E%E5%BF%86/0000.jpg" alt="和本组的帅哥美女"></p>]]></content>
      
      
      <categories>
          
          <category> 回忆 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高中 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈各种排序</title>
      <link href="/2022/11/30/%E6%B5%85%E8%B0%88%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/11/30/%E6%B5%85%E8%B0%88%E5%90%84%E7%A7%8D%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p>排序是我们在学习编程的过程中经常用的问题，这篇博客会总结一些我比较常用的一些算法，以供复习和回忆。</p><p>比较常见的排序大致分为两种，<strong>比较型排序</strong>和<strong>非比较型排序</strong></p><ul><li>比较型排序将元素之间两两进行比较，<em>比较耗时间</em>。</li><li>非比较型排序将元素进行记录，<em>比较耗空间</em>。</li></ul><p><em><strong>我们通常认为时间比空间重要，故经常使用牺牲空间的方式来减少运行时间</strong></em></p><h2 id="比较型排序"><a href="#比较型排序" class="headerlink" title="比较型排序"></a>比较型排序</h2><h3 id="一、插入排序"><a href="#一、插入排序" class="headerlink" title="一、插入排序"></a>一、插入排序</h3><p>一个无序数列，从左到右每次取一个数向左依次比较，直至左边有一个数比它小，则插入。</p><blockquote><p>时间复杂度：O(N)~O(N<sup>2)<br>空间复杂度：O(1)</sup></p></blockquote><p>代码部分：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;void InsertSort(int arr[],int n)&#123;for(int i&#x3D;0;i&lt;n-1;++i)&#123;  &#x2F;&#x2F;第一个已经排好序，没必要再参与计算        int end&#x3D;i;    &#x2F;&#x2F;记录有序序列当前最后元素的下标        int temp&#x3D;arr[end+1];    &#x2F;&#x2F;待插入的元素        while(end&gt;&#x3D;0)&#123;            if(arr[end]&gt;temp)&#123;                    arr[end+1]&#x3D;arr[end];    &#x2F;&#x2F;比插入的数大就向后移                end--;            &#125;            else                break;    &#x2F;&#x2F;比插入的数小，跳出循环        &#125;        arr[end+1]&#x3D;temp;    &#x2F;&#x2F;放入temp&#125;&#125;int main() &#123;    int arr[20],i,n;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);    &#125;    InsertSort(arr,n);    for(i&#x3D;0;i&lt;n;i++)&#123;        printf(&quot;%d &quot;,arr[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="二、冒泡排序"><a href="#二、冒泡排序" class="headerlink" title="二、冒泡排序"></a>二、冒泡排序</h3><p>也是我比较喜欢用的一种排序，每次从左到右相邻的元素两两比较，第一个与第二个比较，让大的那个与第三个比较。这样可以使最大的数排在最右边。</p><blockquote><p>时间复杂度：O(N)~O(N<sup>2)<br>空间复杂度：O(1)</sup></p></blockquote><p>代码部分：</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;void BubbleSort(int arr[],int n)&#123;    int i,j,temp&#x3D;0;    for(i&#x3D;0;i&lt;n-1;i++)&#123;        for(j&#x3D;i+1;j&lt;n;j++)&#123;            if(arr[i]&gt;arr[j])&#123;                temp&#x3D;arr[i];                arr[i]&#x3D;arr[j];                arr[j]&#x3D;temp;            &#125;        &#125;    &#125;&#125;int main() &#123;    int arr[20],i,n;    scanf(&quot;%d&quot;,&amp;n);    for(i&#x3D;0;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);    &#125;    BubbleSort(arr,n);    for(i&#x3D;0;i&lt;n;i++)&#123;        printf(&quot;%d &quot;,arr[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="非比较型排序"><a href="#非比较型排序" class="headerlink" title="非比较型排序"></a>非比较型排序</h2><h3 id="计数排序（Count-sort）"><a href="#计数排序（Count-sort）" class="headerlink" title="计数排序（Count sort）"></a>计数排序（Count sort）</h3><p>计数排序也就是我们刚接触数组时使用的排序方法，快于任何一种比较型排序算法，但条件较为苛刻：<strong>数据范围较小，否则非常浪费空间</strong></p><blockquote><p><strong>k为数组长度</strong><br>时间复杂度就是O(n+k)<br>空间复杂度为O(k)</p></blockquote><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int main() &#123;    int arr[1000],brr[1000]&#x3D;&#123;0&#125;;    int n,i,j;    scanf(&quot;%d&quot;,&amp;n);    scanf(&quot;%d&quot;,&amp;arr[0]);    brr[arr[0]]++;    int max&#x3D;arr[0];    for(i&#x3D;1;i&lt;n;i++)&#123;        scanf(&quot;%d&quot;,&amp;arr[i]);        brr[arr[i]]++;        if(arr[i]&gt;max)            max&#x3D;arr[i];    &#125;    for(i&#x3D;0;i&lt;max+1;i++)&#123;        for(j&#x3D;0;j&lt;brr[i];j++)&#123;            printf(&quot;%d &quot;,i);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈二分查找</title>
      <link href="/2022/11/29/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2022/11/29/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>相信我们都在编程过程中遇见查找问题，而查找的方式有许多种，我们最常见的、也是使用次数最多的便是<em><strong>二分查找</strong></em>了，原理简单且不容易超时。<br>二分查找的思想很容易理解，但大多数人都是通过记模板来使用，这篇博客将二分法做一个大概的总结，以供记忆和复习。</p><h2 id="一、分享小故事"><a href="#一、分享小故事" class="headerlink" title="一、分享小故事"></a>一、分享小故事</h2><p>这里引用了CSDN中<a href="https://blog.csdn.net/qq_45978890/article/details/116094046?spm=1001.2014.3001.5502">Charon_cc</a>的一个很生动形象的例子：</p><hr><blockquote><p>有一天小明到图书馆借了 N 本书，出图书馆的时候，警报响了，于是保安把小明拦下，要检查一下哪本书没有登记出借。小明正准备把每一本书在报警器下过一下，以找出引发警报的书，但是保安露出不屑的眼神：你连二分查找都不会吗？于是保安把书分成两堆，让第一堆过一下报警器，报警器响；于是再把这堆书分成两堆…… 最终，检测了 logN 次之后，保安成功的找到了那本引起警报的书，露出了得意和嘲讽的笑容。于是小明背着剩下的书走了。 从此，图书馆丢了 N - 1 本书。</p></blockquote><hr><p>多读两遍我们就会发现<mark>二分查找法的前提<mark>：</mark></mark></p><h2 id="二、二分查找的前提"><a href="#二、二分查找的前提" class="headerlink" title="二、二分查找的前提"></a>二、二分查找的前提</h2><ul><li><strong>查找的目标只能有一个</strong></li><li><strong>查找的范围内元素是有序的</strong>（排序在C++里可以直接使用sort，而在C里可以使用冒泡排序等方法）</li></ul><p>为什么是这样的一个前提呢？我们首先应该知道<mark>二分查找的原理<mark>：</mark></mark></p><h2 id="三、二分查找的原理"><a href="#三、二分查找的原理" class="headerlink" title="三、二分查找的原理"></a>三、二分查找的原理</h2><blockquote><p>在一个已经从小到大排好的数组里，先把目标与数组中间值比较<br>* 若目标&gt;中间值，则接着找后半部分，前半部分舍弃。<br>* 若目标&lt;中间值，则接着找前半部分，后半部分舍弃。</p></blockquote><p>那有初学的朋友会问了：<em>数组元素数是偶数的话怎么取中间值？</em></p><p>其实不必纠结这个问题，因为每次都丢掉数组的一半的话，这个问题是一定会出现的。</p><p>虽说叫二分查找，但并不是说我们必须严格的取一半，只是取一半时舍弃掉的不合要求的元素最多，比较节约时间而已。<br>而由于我们使用<strong>int</strong>类型，每次取的就是最中间两个数中靠左的那个，这样一来无非是在搜索的范围里多加一个数而已，只要我们继续进行二分查找并找好边界值，就永远不会有元素被落下。</p><h2 id="四、二分查找的使用"><a href="#四、二分查找的使用" class="headerlink" title="四、二分查找的使用"></a>四、二分查找的使用</h2><p>这里只写我最常用的一种方式：<mark>[left,right]式<mark><br>使用int函数进行运算：</mark></mark></p><pre class="line-numbers language-none"><code class="language-none">int binarysearch(int arr[],int size,int target)&#123;    &#x2F;&#x2F;size 可使用int size&#x3D;sizeof(arr)&#x2F;sizeof(arr[0])计算    int l&#x3D;0,r&#x3D;size-1;   &#x2F;&#x2F;l&#x3D;left,r&#x3D;right,m&#x3D;middle    while(l&lt;&#x3D;r)&#123;        int m&#x3D;l+(r-l)&#x2F;2;    &#x2F;&#x2F;防止直接相加导致溢出        if(arr[m]&gt;target)&#123;            r&#x3D;m-1;        &#125;        else if(arr[m]&lt;target)&#123;            l&#x3D;m+1;        &#125;        else            return m;    &#125;    return -1;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="五、二分查找的性能"><a href="#五、二分查找的性能" class="headerlink" title="五、二分查找的性能"></a>五、二分查找的性能</h2><ul><li>时间复杂度：O(1)~O(log<sub>2</sub>n)</li><li>空间复杂度：O(1)~O(log<sub>2</sub>n)</li></ul>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最大公因数和最小公倍数（欧几里得算法）</title>
      <link href="/2022/11/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
      <url>/2022/11/28/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>我们在学习时经常性遇见求最大公因数和最小公倍数的问题，而使用枚举的话非常容易超时，那么我们应该怎样更快更好地解决它们呢?</p><span id="more"></span><h2 id="最大公因数"><a href="#最大公因数" class="headerlink" title="最大公因数"></a>最大公因数</h2><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>又称<em>辗转相除法</em>，使用int类型的函数实现，两个参数的传入条件要求<em><strong>a大于b</strong></em>。<br><strong>百度百科</strong>：欧几里得算法又称辗转相除法，是指用于计算两个非负整数a，b的最大公约数。应用领域有数学和计算机两个方面。计算公式gcd(a,b) = gcd(b,a mod b)。<br>总之就是不断把<em>除数当被除数，余数当除数</em><br>假如需要求 1997 和 615 两个正整数的最大公约数,用欧几里得算法，是这样进行的：<br>1997 ÷ 615 = 3 (余 152)<br>615 ÷ 152 = 4(余7)<br>152 ÷ 7 = 21(余5)<br>7 ÷ 5 = 1 (余2)<br>5 ÷ 2 = 2 (余1)<br>2 ÷ 1 = 2 (余0)<br>至此，最大公约数为1<br>以除数和余数反复做除法运算，当余数为 0 时，取当前算式除数为最大公约数，所以就得出了 1997 和 615 的最大公约数 1。</p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int gcd(int a,int b)&#123;    int t;    if(a&lt;b)&#123;  &#x2F;&#x2F;使大的作被除数        t&#x3D;a;a&#x3D;b;b&#x3D;t;    &#125;    if(b&#x3D;&#x3D;0)  &#x2F;&#x2F;判断是否存在0的情况        return a;    else        return gcd(b,a%b);&#125;int main()&#123;    int a,b;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    printf(&quot;%d&quot;,gcd(a,b));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="最小公倍数"><a href="#最小公倍数" class="headerlink" title="最小公倍数"></a>最小公倍数</h2><p>相信你已经学会求最大公因数，那么最小公倍数呢？<br><strong>当然也是非常简单滴！</strong><br><em><strong>最小公倍数=（ab）/最大公因数</strong></em></p><pre class="line-numbers language-none"><code class="language-none">#include &lt;stdio.h&gt;int gcd(int a,int b)&#123;    int t;    if(a&lt;b)&#123;  &#x2F;&#x2F;使大的作被除数        t&#x3D;a;a&#x3D;b;b&#x3D;t;    &#125;    if(b&#x3D;&#x3D;0)  &#x2F;&#x2F;判断是否存在0的情况        return a;    else        return gcd(b,a%b);&#125;int main()&#123;    int a,b;    scanf(&quot;%d%d&quot;,&amp;a,&amp;b);    printf(&quot;%d&quot;,(a*b)&#x2F;gcd(a,b));    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 求数 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/messageboard/index.html"/>
      <url>/messageboard/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>myself</title>
      <link href="/myself/index.html"/>
      <url>/myself/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>日志</title>
      <link href="/timeline/index.html"/>
      <url>/timeline/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
